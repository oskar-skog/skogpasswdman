#!/usr/bin/python
copywrong = """
Copyright (c) 2014, Oskar Skog <oskar.skog.finland@gmail.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1.  Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE."""
import passwdmanapi as api
import curses, math, os, tarfile, sys

__doc__ = """import passwdmanapi as api
h, p = api.honeypot(), api.passwd()
code = locale.getpreferredencoding()
tty = curses.initscr()
ysize, xsize = tty.getmaxyx()
0 <= tabnum <= 3 (main.__doc__, set_tab.__doc__)
have_clipboard = True or False
See also copy.__doc__, wrap_addch.__doc__, wrap_addstr.__doc__, busy.__doc__,
edit_line.__doc__, edit_num.__doc__, main.__doc__, show_copy_single.__doc__
and center_text.__doc__.
"""

def die():
    """die() - exit curses mode and quit."""
    tty.keypad(0)
    curses.echo()
    curses.nocbreak()
    curses.endwin()
    quit()

def wrap_addch(y, x, c):
    """wrap_addch(y, x, c) - tty.addch(y, x, c), without the evil corner."""
    try:
        tty.addch(y, x, c)
    except:
        #Row 23 column 79 (bottom right) is evil.
        #Usually attempted by center_text().
        pass

def wrap_addstr(y, x, s):
    """wrap_addstr(y, x, s) - encode in Python2, decode in Python3
    tty.addstr(y, x, s)"""
    v, f, f, f, f = sys.version_info
    tty.addstr(y, x, api.b2u3(s))

def center_text(line, text):
    """center_text(line, text) - put text <text> in the center of line <line>.
    Long lines f text will be truncated."""
    assert api.is_anystr(text) and line >= 0 and line < ysize
    start_pos = math.floor((xsize - len(text)) / 2)
    for x in range(xsize):
        if x < start_pos or x >= start_pos + len(text):
            wrap_addch(line, x, ord(" "))
        else:
            wrap_addch(line, x, ord(text[int(x - start_pos)]))

def busy():
    """busy() - ``set busy cursor``"""
    tty.erase()
    center_text(2, "Wait...")
    tty.refresh()

def edit_num(y, num, min_num, max_num, step=1):
    """direction, num = edit_num(y, num, min_num, max_num, step=1)
    num is the starting number/number.
    direction is how the user made this function return.
    direction is either "up", "down" or "back".
    min_num and max_num are num's limits. None = unlimited
    y is the Y-coordinate.
    step is how much to increase/decrease per key-press."""
    assert y >= 0 and y < ysize
    if min_num is not None and max_num is not None:
        assert max_num >= min_num
    while True:
        #Keep num within limits.
        if min_num is not None:
            if num < min_num:
                num = min_num
        if max_num is not None:
            if num > max_num:
                num = max_num
        #Print.
        tty.hline(y, 0, ord(" "), xsize)
        center_text(y, "left - a h home<" + str(num) + ">right + d l end")
        tty.refresh()
        ch = tty.getch()
        if ch in (curses.KEY_LEFT, ord("-"), ord("a"), ord("h")):
            num -= step
            continue
        if ch in (curses.KEY_RIGHT, ord("+"), ord("d"), ord("l")):
            num += step
            continue
        #Increase/decrease 5 * step if there is no limit in that direction.
        if ch in (curses.KEY_HOME, ord("A"), ord("H")):
            if min_num is not None:
                num = min_num
            else:
                num -= step * 5
            continue
        if ch in (curses.KEY_END, ord("D"), ord("L")):
            if max_num is not None:
                num = max_num
            else:
                num += step * 5
            continue
        #Return.
        if ch in (ord(" "), ord("\t"), ord("\n"), curses.KEY_DOWN):
            return "down", num
        if ch == curses.KEY_UP:
            return "up", num
        if ch == 27:
            return "back", num

def edit_line(y, line):
    """direction, line = edit_line(y, line)
    direction is how the user made this function return.
    direction is either "up", "down" or "back".
    line is the line of text that will be/has been edited.
    y is the Y-coordinate."""
    #Unicode string.
    if line is None:
        head_u = api.u("")
    else:
        head_u = api.u(line)
    #Byte string.
    ver, f, f, f, f = sys.version_info
    if ver == 2:
        head_b = ""
        def mk_head_b():
            return head_u.encode(code)
    else:
        head_b = []
        def mk_head_b():
            return list(head_u.encode(code))
    #Tail.
    tail = api.u("")
    half_len = int(math.floor(xsize / 2))
    while True:
        tty.hline(y, 0, ord(" "), xsize)
        #Print line.
        if len(head_u) < xsize - 1:
            wrap_addstr(y, 0, head_u)
            wrap_addstr(y, len(head_u), tail[:xsize - len(head_u)])
            tty.move(y, len(head_u))
        else:
            wrap_addstr(y, 0, head_u[-half_len:])
            wrap_addstr(y, half_len, tail[:half_len])
            tty.move(y, half_len)
        tty.refresh()
        #Input.
        ch = tty.getch()
        #Navigate in string.
        if ch == curses.KEY_HOME:
            tail = head_u + tail
            head_u = api.u("")
            head_b = mk_head_b()
        elif ch == curses.KEY_END:
            head_u = head_u + tail
            tail = api.u("")
            head_b = mk_head_b()
        elif ch == curses.KEY_LEFT:
            if len(head_u) > 0:
                head_u, tail = head_u[:-1], head_u[-1] + tail
                head_b = mk_head_b()
        elif ch == curses.KEY_RIGHT:
            if len(tail) > 0:
                head_u, tail = head_u + tail[0], tail[1:]
                head_b = mk_head_b()
        #Backspace, delete.
        elif ch == curses.KEY_BACKSPACE:
            if len(head_u) > 0:
                head_u = head_u[:-1]
                head_b = mk_head_b()
        elif ch == curses.KEY_DC:
            if len(tail) > 0:
                tail = tail[1:]
        #Return.
        elif ch in (curses.KEY_DOWN, ord("\t"), ord("\n")):
            return "down", head_u + tail
        elif ch == curses.KEY_UP:
            return "up", head_u + tail
        elif ch == 27:
            return "back", head_u + tail
        elif ch < 256:
            #Loop until multibyte char is done.
            if ver == 2:
                head_b += chr(ch)
                head_u = head_b.decode(code, "ignore")
            else:
                head_b.append(ch)
                head_u = bytes(head_b).decode(code, "ignore")

def after_update(old, new):
    """after_update(old, new)
    Show old and new passwords and let the user copy them to clipboard."""
    tty.erase()
    if (math.ceil(len(old) / xsize + 0.0) +
            math.ceil(len(new) / xsize + 0.0) + 2) > ysize - 2:
        raise api.err_idiot("Not implented!")
    else:
        if have_clipboard:
            center_text(0, "Old: (Press 1 to copy)")
        else:
            center_text(0, "Old:")
        x_pos, y_pos = 0, 1
        for c in old:
            if x_pos >= xsize:
                x_pos = 0
                y_pos += 1
            wrap_addstr(y_pos, x_pos, c)
            x_pos += 1
        if x_pos != 0: #Has it rolled over and increased y_pos?
            y_pos += 1
            x_pos = 0
        if have_clipboard:
            center_text(y_pos, "New: (Press 2 to copy)")
        else:
            center_text(y_pos, "New:")
        y_pos += 1
        for c in new:
            if x_pos >= xsize:
                x_pos = 0
                y_pos += 1
            wrap_addstr(y_pos, x_pos, c)
            x_pos += 1
        center_text(ysize - 1, "Press any other key to finish.")
        tty.refresh()
        while True:
            ch = tty.getch()
            if ch == ord("1") and have_clipboard:
                copy(old)
            elif ch == ord("2") and have_clipboard:
                copy(new)
            else:
                return

def dictui(arg):
    ret_arg = {}
    where = wrap = 0
    # Initialize.
    for i in arg:
        try:
            if i['type'] not in ('space', 'text'):
                wrap += 1
            if i['type'] in ('edit_num', 'edit_line'):
                try:
                    ret_arg[i['name']] = i['value']
                except KeyError:
                    if i['type'] == 'edit_num':
                        ret_arg[i['name']] = 1
                    else:
                        ret_arg[i['name']] = ""
            else:
                # Check the button.
                try:
                    forget = i['name']
                except KeyError:
                    # No name.
                    try:
                        i['name'] = i['value']
                    except KeyError:
                        # No value.
                        i['name'] = 'OK'
                try:
                    forget = i['value']
                except KeyError:
                    i['value'] = i['name']
        except KeyError:
            pass
    # Main loop.
    while True:
        tty.erase()
        # Print.
        foobar = 0      # I cannot figure out a good name for this one.
        for y in range(len(arg)):
            # y is both the Y coordinate and the index for arg.
            try:
                if arg[y]["type"] == "space":
                    pass
                elif arg[y]["type"] == "text":
                    center_text(y, arg[y]["value"])
                else:
                    assert arg[y]["type"] in ("edit_line","edit_num","button")
                    if arg[y]["type"] == "edit_line":
                        center_text(y, ret_arg[arg[y]["name"]])
                    if arg[y]["type"] == "edit_num":
                        center_text(y, str(ret_arg[arg[y]["name"]]))
                    if arg[y]["type"] == "button":
                        center_text(y, arg[y]["value"])
                    if foobar == where:
                        wrap_addstr(y, 0, "**")
                        wrap_addstr(y, xsize - 2, "**")
                    foobar += 1
            except KeyError:
                pass
        tty.refresh()
        # Input.
        foobar = 0
        for y in range(len(arg)):
            try:
                if foobar == where:
                    direction = None
                    if arg[y]["type"] == "edit_line":
                        direction, ret_arg[arg[y]["name"]] = edit_line(y,
                                                ret_arg[arg[y]["name"]])
                    if arg[y]["type"] == "edit_num":
                        # Set the defaults if necessary.
                        try:
                            min_num = arg[y]["min"]
                        except:
                            min_num = None
                        try:
                            max_num = arg[y]["max"]
                        except:
                            max_num = None
                        try:
                            step = arg[y]["step"]
                        except:
                            step = 1
                        direction, ret_arg[arg[y]["name"]] = edit_num(y,
                            ret_arg[arg[y]["name"]], min_num, max_num, step)
                    if arg[y]["type"] == "button":
                        ch = tty.getch()
                        if ch == curses.KEY_UP:
                            direction = "up"
                        elif ch in (curses.KEY_DOWN, ord("\t")):
                            direction = "down"
                        elif ch == 27:
                            direction = "back"
                        elif ch in (ord(" "), ord("\n")):
                            ret_arg["button"] = arg[y]["name"]
                            return ret_arg
                        elif ch == curses.KEY_PPAGE:
                            where = 0
                            break # Back to main loop.
                        elif ch == curses.KEY_NPAGE:
                            where = wrap - 1
                            break # Back to main loop.
                    # Check what value direction has.
                    assert direction in ("up", "down", "back", None)
                    if direction == "back":
                        ret_arg["button"] = "back"
                        return ret_arg
                    if direction == "up":
                        where -= 1
                        break   # Back to main loop.
                    if direction == "down":
                        where += 1
                        break   # Back to main loop.
                if arg[y]["type"] in ("button", "edit_num", "edit_line"):
                    foobar += 1
            except KeyError:
                pass
        # Keep where in range.
        where %= wrap

def passwd_tab(x):
    """passwd_tab(x)
    x is the action to be performed on a password.
    x begins from 0 (Copy to clipboard), or from 1 (Show password) if not
    have_clipboard.
    See also choice.__doc__ and after_update.__doc__.
    """
    assert x >= 0 and x < 7
    if x < 4 or x == 6:
        selection = choice(False)
        if isinstance(selection, bool):
            assert selection == False
            return      #Will never return True.
    if x == 0:
        # Copy to clipboard.
        assert have_clipboard
        copy(p[selection]["value"])
    if x == 1:
        # Show password.
        tty.erase()
        if len(p[selection]["value"]) > (ysize - 2) * xsize:
            raise api.err_idiot("Not implented!")
        else:
            x_pos = y_pos = 0
            for c in p[selection]["value"]:
                if x_pos >= xsize:
                    x_pos = 0
                    y_pos += 1
                wrap_addstr(y_pos, x_pos, c)
                x_pos += 1
            center_text(ysize - 1, "Press any key.")
            tty.refresh()
            tty.getch()
    if x == 2:
        busy()
        old = p[selection]["value"]
        p.update(selection)
        new = p[selection]["value"]
        after_update(old, new)
    if x == 3:
        #Change meta-data and update.
        if p[selection]["meta"]["type"] in ("10", "64"):
            minlen = int(p[selection]["meta"]["minlength"])
            maxlen = int(p[selection]["meta"]["maxlength"])
        else:
            assert p[selection]["meta"]["type"] == "human"
            minlen = maxlen = 8
        result = dictui([
            {
                'type': 'text',
                'value': 'Minimal required length'
            }, {
                'type': 'edit_num',
                'name': 'min',
                'value': minlen,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': 'Maximal allowed length'
            }, {
                'type': 'edit_num',
                'name': 'max',
                'value': maxlen,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': "Big & small letters, digits, '!', '_'"
            }, {
                'type': 'button',
                'name': '64',
                'value': 'OK'
            }, {}, {
                'type': 'text',
                'value': 'Digits only'
            }, {
                'type': 'button',
                'name': '10',
                'value': 'OK'
            }])
        if result["button"] == "back":
            return
        busy()
        old = p[selection]["value"]
        #BUG TODO stop user from having minlength > maxlength.
        p.update_meta(selection, result["button"],
                                        result["min"], result["max"])
        new = p[selection]["value"]
        after_update(old, new)
    if x == 4:
        result = dictui([
            {
                'type': 'text',
                'value': 'What is the password for?'
            }, {
                'type': 'edit_line',
                'name': 'name'
            }, {}, {
                'type': 'text',
                'value': 'What is the password?'
            }, {
                'type': 'edit_line',
                'name': 'value'
            }, {}, {
                'type': 'button'
            }])
        if result["button"] == "back":
            return
        p.add_nometa(result["name"], result["value"])
    if x == 5:
        #Create new.
        result = dictui([
            {
                'type': 'text',
                'value': 'What is the password for?'
            }, {
                'type': 'edit_line',
                'name': 'name'
            }, {}, {
                'type': 'text',
                'value': 'Minimal required length'
            }, {
                'type': 'edit_num',
                'name': 'minlen',
                'value': 8,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': 'Maximal allowed length'
            }, {
                'type': 'edit_num',
                'name': 'maxlen',
                'value': 8,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': "Big & small letters, digits, '!', '_'"
            }, {
                'type': 'button',
                'name': '64',
                'value': 'OK'
            }, {}, {
                'type': 'text',
                'value': 'Digits only'
            }, {
                'type': 'button',
                'name': '10',
                'value': 'OK'
            }])
        if result == "back":
            return
        busy()
        #BUG TODO stop user from having minlength > maxlength.
        p.add(result["name"], None, result["button"], result["minlen"],
                                                        result["maxlen"])
    if x == 6:
        # Remove.
        p.remove(selection)

def show_copy_single(s):
    """show_copy_single(s)
    Show a string and let the user copy it to clipboard."""
    if len(s) > (ysize - 3) * xsize:
        raise api.err_idiot("Not implented!")
    else:
        tty.erase()
        x_pos = y_pos = 0
        for c in s:
            if x_pos >= xsize:
                x_pos = 0
                y_pos += 1
            wrap_addstr(y_pos, x_pos, c)
            x_pos += 1
        if have_clipboard:
            center_text(ysize - 2, "Press 1 to copy.")
            center_text(ysize - 1, "Press any other key to finish.")
        else:
            center_text(ysize - 1, "Press any key to finish.")
        tty.refresh()
        while True:
            ch = tty.getch()
            if ch == ord("1") and have_clipboard:
                copy(s)
            else:
                break

def honeypot_tab(x):
    """honeypot_tab(x)
    x is the action to be performed on a honeypot.
    x begins from 0 (Pick & copy), or from 1 (Pick & show) if not
    have_clipboard.
    See also choice.__doc__"""
    assert x >= 0 and x < 6
    if x == 0:
        #Pick & copy.
        assert have_clipboard
        copy(h.pick())
    if x == 1:
        #Pick & show.
        tty.erase()
        s = h.pick()
        if len(s) > (ysize - 2) * xsize:
            raise api.err_idiot("Not implented!")
        else:
            x_pos = y_pos = 0
            for c in s:
                if x_pos >= xsize:
                    x_pos = 0
                    y_pos += 1
                wrap_addstr(y_pos, x_pos, c)
                x_pos += 1
            center_text(ysize - 1, "Press any key.")
            tty.refresh()
            tty.getch()
    if x == 2:
        #Bad pick many.
        where = 0
        num = 1
        sep = ","
        tty.erase()
        while True:
            if where != 0:
                center_text(0, "  How many?  ")
            if where != 1:
                center_text(3, "  Separate them with?  ")
            if where != 2:
                center_text(6, "  OK  ")
            if where == 0:
                center_text(0, "**How many?**")
                direction, num = edit_num(1, num, 1, len(h))
                if direction == "up":
                    where = 2
                    continue
                if direction == "down":
                    where = 1
                    continue
                assert direction == "back"
                return
            if where == 1:
                center_text(3, "**Separate them with?**")
                direction, sep = edit_line(4, sep)
                if direction == "up":
                    where = 0
                    continue
                if direction == "down":
                    where = 2
                    continue
                assert direction == "back"
                return
            if where == 2:
                center_text(6, "**OK**")
                tty.refresh()
                ch = tty.getch()
                if ch == curses.KEY_UP:
                    where = 1
                    continue
                if ch in (curses.KEY_DOWN, ord("\t")):
                    where = 0
                    continue
                if ch in (ord(" "), ord("\n")):
                    break
                if ch == 27:
                    return
        busy()
        s = h.pick(num, sep)
        show_copy_single(s)
    if x == 3:
        #Good pick many.
        where = 0
        num = 1
        tty.erase()
        while True:
            if where != 0:
                center_text(0, "  How many?  ")
            if where != 1:
                center_text(3, "  OK  ")
            if where == 0:
                center_text(0, "**How many?**")
                direction, num = edit_num(1, num, 1, len(h))
                if direction == "up":
                    where = 1
                    continue
                if direction == "down":
                    where = 1
                    continue
                assert direction == "back"
                return
            if where == 1:
                center_text(3, "**OK**")
                tty.refresh()
                ch = tty.getch()
                if ch == curses.KEY_UP:
                    where = 0
                    continue
                if ch in (curses.KEY_DOWN, ord("\t")):
                    where = 0
                    continue
                if ch in (ord(" "), ord("\n")):
                    break
                if ch == 27:
                    return
        busy()
        result = h.pickl(num)
        for s in result:
            show_copy_single(s)
    if x == 4:
        #Add.
        tty.erase()
        where = 0
        line = None
        while True:
            if where == 0:
                center_text(0, "**What is the fake-password?**")
                center_text(3, "  Add  ")
                direction, line = edit_line(1, line)
                if direction == "back":
                    return
                else:
                    assert direction in ("up", "down")
                    where = 1
            if where == 1:
                center_text(0, "  What is the fake-password?  ")
                center_text(3, "**Add**")
                tty.refresh()
                ch = tty.getch()
                if ch in (ord("\n"), ord(" ")):
                    h.add(line)
                    return
                if ch == 27:
                    return
                if ch in (ord("\t"), curses.KEY_UP, curses.KEY_DOWN):
                    where = 0
    if x == 5:
        #Remove.
        selection = choice(True)
        if isinstance(selection, bool):
            assert selection == False
            return      #Will never return True.
        h.remove(selection)

def copy(x):
    """copy(s)
    copy s to the clipboard.
    Not written by me."""
    # "primary":
    xsel_proc = subprocess.Popen(['xsel', '-pi'], stdin=subprocess.PIPE)
    xsel_proc.communicate(api.b(x))
    # "clipboard":
    xsel_proc = subprocess.Popen(['xsel', '-bi'], stdin=subprocess.PIPE)
    xsel_proc.communicate(api.b(x))

def set_tab(direction):
    """set_tab(direction)
    Move to another tab in main().
    0 <= direction <= 3 or direction in ("<", ">")"""
    global tabnum
    try:
        x = int(direction)
        tabnum = x
    except:
        if direction == ">":
            tabnum += 1
        elif direction == "<":
            tabnum -= 1
        else:
            raise api.err_idiot("What the fuck does that mean?")
    if tabnum < 0:
        tabnum = 0
    if tabnum > 3:
        tabnum = 3

def choice(honeypot):
    """choice(honeypot)
    Return index for p if honeypot == False.
    Return index for h if honeypot == True.
    Returns False if the user cancels."""
    tty.erase()
    thelist = []
    if honeypot:
        center_text(0, "Please select fake-password.")
        for x in h:
            thelist.append(x)
    else:
        center_text(0, "Please select password.")
        for x in p:
            thelist.append(x["name"])
    if len(thelist) > 0:
        #I know this will ask the user even if there only is one choice, but
        #it will show which password/honeypot the only one is.
        return list_choice(1, ysize - 1, thelist)
    else:
        return False

def zxcv_handler(x):
    """zxcv_handler(x)
    x is whatever tty.getch() has returned.
    Handle undo/redo/make backup/clear clipboard."""
    if x in (ord("z"), ord("Z"), ord("b"), ord("B")):
        api.undo(p, h)
    if x in (ord("x"), ord("X"), ord("n"), ord("N")):
        api.redo(p, h)
    if x in (ord("c"), ord("C"), ord("m"), ord("M")):
        tty.erase()
        where = 0
        tarball_name = None
        while True:
            if where == 0:
                center_text(0, "**path**")
                center_text(3, "  OK  ")
                direction, tarball_name = edit_line(1, tarball_name)
                if direction == "back":
                    return
                assert direction in ("up", "down")
                where = 1
            if where == 1:
                center_text(0, "  path  ")
                center_text(3, "**OK**")
                tty.refresh()
                ch = tty.getch()
                if ch in (ord(" "), ord("\n")):
                    break
                if ch == 27:
                    return
                if ch in (ord("\t"), curses.KEY_UP, curses.KEY_DOWN):
                    where = 0
        try:    #Normal suffix?
            test = tarball_name[-4:] == ".tgz"
            if not test:
                test = tarball_name[-7:] == ".tar.gz"
        except:
            test = False
        if not test:
            tty.erase()
            center_text(0, "Append suffix (Y/N)?")
            tty.refresh()
            while True:
                ch = tty.getch()
                if ch in (ord("y"), ord("Y")):
                    tarball_name += ".tar.gz"
                    break
                if ch in (ord("n"), ord("N")):
                    break
        old_dir = os.getcwd()
        os.chdir(os.path.expanduser("~"))
        tarball = tarfile.open(os.path.expanduser(tarball_name), "w:gz")
        tarball.add(".passwdman")
        tarball.close()
        os.chdir(old_dir)
    if have_clipboard and x in (ord("v"), ord("V"), ord(",")):
        copy("EMPTY")

def list_choice(ypos, yspace, thelist, ct = False):
    """list_choice(ypos, yspace, thelist, ct = False)
    thelist is a list of strings (buttons).
    It can change tabs if ct == True.
    Returns True if the user changed tab.
    Returns False if the user canceled.
    Returns an index to thelist if the user has `clicked` on one of the
    buttons.
    ypos is the Y-coordinate.
    yspace is the number of rows list_choice() will eat of the screen.
    See also zxcv_handler.__doc__"""
    assert len(thelist) > 0
    xspace = 0
    for x in thelist:
        if len(x) > xspace:
            xspace = len(x)
    xspace += 4
    assert yspace >= 7 and xspace <= xsize
    center_text(ypos, "Page-up up w k 8")
    center_text(ypos + 1, "Choose with space, tab or enter")
    center_text(ypos + 2, "or escape to cancel.")
    center_text(ypos + yspace - 1, "Page-down down s j 2")
    page = yspace - 6
    if xsize - xspace >= 8: #Enough room for "<-Choose"?
        show_arrow = True
    else:
        show_arrow = False
    choice = 0
    size = len(thelist)
    while True:
        #Draw.
        for i in range(page):
            #Surrounding brackets.
            wrap_addch(i + ypos + 4, 0, ord("["))
            wrap_addch(i + ypos + 4, xspace - 1, ord("]"))
            #Past end?
            if i + (choice - choice % page) >= size:
                #Put empty
                tty.hline(i + ypos + 4, 0, ord("-"), xspace)
                tty.hline(i + ypos + 4, xspace, 32, xsize - xspace)
            else:
                #put line
                if choice % page == i:  #Selected?
                    wrap_addch(i + ypos + 4, 1, ord("*"))
                    wrap_addch(i + ypos + 4, xspace - 2, ord("*"))
                    if show_arrow:
                        wrap_addstr(i + ypos + 4, xspace, "<-Choose")
                else:
                    if show_arrow:
                        tty.hline(i + ypos + 4, xspace, 32, xsize - xspace)
                    wrap_addch(i + ypos + 4, 1, ord(" "))
                    wrap_addch(i + ypos + 4, xspace - 2, ord(" "))
                #Print the characters.
                for x in range(2, xspace - 2):
                    if x - 2 >= len(thelist[(i +        #Iterate for one page.
                            choice - choice % page)]):  #Which page * page.
                        wrap_addch(i + ypos + 4, x, ord(" "))
                    else:
                        wrap_addstr(i + ypos + 4, x, thelist[int(i +
                            choice - choice % page)][x - 2])
        #Print the 'rollability-indicators'.
        if choice - page < 0:
            tty.hline(ypos + 3, 0, ord("-"), xspace)
        else:
            tty.hline(ypos + 3, 0, ord("^"), xspace)
        if choice + page - choice % page > len(thelist) - 1:
            tty.hline(ypos + yspace - 2, 0, ord("-"), xspace)
        else:
            tty.hline(ypos + yspace - 2, 0, ord("v"), xspace)
        tty.refresh()
        #Handle input.
        ch = tty.getch()
        if ct:  #Change tab?
            if ch in (ord("4"), ord("a"), ord("h"), curses.KEY_LEFT):
                set_tab("<")
                return True
            if ch in (ord("6"), ord("d"), ord("l"), curses.KEY_RIGHT):
                set_tab(">")
                return True
            if ch in (ord("A"), ord("H"), curses.KEY_HOME):
                set_tab(0)
                return True
            if ch in (ord("D"), ord("L"), curses.KEY_END):
                set_tab(3)
                return True
        if ch == 27:    #Escape
            return False
        if ch in (ord("8"), ord("w"), ord("k"), curses.KEY_UP):
            choice -= 1
        if ch in (ord("2"), ord("s"), ord("j"), curses.KEY_DOWN):
            choice += 1
        if ch in (ord("W"), ord("K"), curses.KEY_PPAGE):
            choice -= page
        if ch in (ord("S"), ord("J"), curses.KEY_NPAGE):
            choice += page
        if ch in (ord("\t"), ord(" "), ord("\n")):
            return choice
        zxcv_handler(ch)
        #Don't let choice be out of range
        if choice >= len(thelist):
            choice = len(thelist) - 1
        if choice < 0:
            choice = 0

def roll_text(ypos, yspace, thetext, ct = False):
    """roll_text(ypos, yspace, thetext, ct = False)
    Show a large amount of text on the screen.
    It can change tabs if ct == True.
    Returns True if the user changed tab.
    Returns False if the user canceled.
    ypos is the Y-coordinate.
    yspace is the number of rows roll_text() will eat of the screen.
    See also zxcv_handler.__doc__"""
    thelines = thetext.split("\n")
    page = yspace - 4
    linepos = 0
    center_text(ypos, "Page-up up W K 8")
    center_text(ypos + yspace - 1, "Page-down down S J 2")
    while True:
        #Print.
        for i in range(page):
            for x in range(xsize):
                try:
                    c = ord(thelines[i + linepos][x])
                except:
                    c = ord(" ")
                wrap_addch(i + ypos + 2, x, c)
        if linepos < 1:
            tty.hline(ypos + 1, 0, ord("-"), xsize)
        else:
            tty.hline(ypos + 1, 0, ord("^"), xsize)
        if linepos + page > len(thelines):
            tty.hline(ypos + yspace - 2, 0, ord("-"), xsize)
        else:
            tty.hline(ypos + yspace - 2, 0, ord("v"), xsize)
        tty.refresh()
        ch = tty.getch()
        if ct:  #Change tab?
            if ch in (ord("4"), ord("a"), ord("h"), curses.KEY_LEFT):
                set_tab("<")
                return True
            if ch in (ord("6"), ord("d"), ord("l"), curses.KEY_RIGHT):
                set_tab(">")
                return True
            if ch in (ord("A"), ord("H"), curses.KEY_HOME):
                set_tab(0)
                return True
            if ch in (ord("D"), ord("L"), curses.KEY_END):
                set_tab(3)
                return True
        if ch == 27:
            return False
        oldpos = linepos
        if ch in (ord("w"), ord("k"), ord("8"), curses.KEY_UP):
            linepos -= 1
        if ch in (ord("s"), ord("j"), ord("2"), curses.KEY_DOWN):
            linepos += 1
        if ch in (ord("W"), ord("K"), curses.KEY_PPAGE):
            linepos -= page
        if ch in (ord("S"), ord("J"), curses.KEY_NPAGE):
            linepos += page
        zxcv_handler(ch)
        if linepos < 0 or linepos >= len(thelines):
            linepos = oldpos

def main():
    """See list_choice.__doc__, passwd_tab.__doc__, honeypot_tab.__doc__,
    roll_text.__doc__ and die.__doc__."""
    global tabnum
    while True:
        #Render.
        tab_names = [["passwords", "fake passwords", "help", "about"],
            ["PASSWORDS", "FAKE PASSWORDS", "HELP", "ABOUT"]]
        tty.erase()
        if xsize >= 80:
            #Tabs.
            s = "Home left a h 4"
            wrap_addstr(0, 0, s)
            wrap_addstr(0, len(s), "::")
            x_pos = len(s) + 2
            for i in range(4):
                if i == tabnum:
                    wrap_addstr(0, x_pos, tab_names[1][i])
                else:
                    wrap_addstr(0, x_pos, tab_names[0][i])
                x_pos += len(tab_names[0][i])
                wrap_addstr(0, x_pos, ":")
                x_pos += 1
            wrap_addstr(0, x_pos, ":6 l d right end")
            #zxcv
            if have_clipboard:
                wrap_addstr(ysize - 2, 0, "(z/b) undo : (x/n) redo : (c/m)" +
                    " Make backup : (v/,) Clear clipboard : (^C) quit")
            else:
                wrap_addstr(ysize - 2, 0, "(z/b) undo : (x/n) redo : (c/m)" +
                    " Make backup : (^C) quit")
            #Lines.
            tty.hline(1, 0, ord("="), xsize)
            tty.hline(ysize - 3, 0, ord("="), xsize)
            tty.refresh()
        else:
            pass    #TODO
        if tabnum == 0: #Passwords.
            thelist = ["Copy to clipboard",
                    "Show password",
                    "Update",
                    "Change meta-data & update",
                    "Add existing",
                    "Create new",
                    "Remove"]
            if have_clipboard:
                result = list_choice(2, ysize - 5, thelist, True)
            else:
                result = list_choice(2, ysize - 5, thelist[1:], True)
                if not isinstance(result, bool):
                    result += 1 #There was no first option.
            #Check for booleans last, to avoid misinterpreting 0 and 1.
            if not isinstance(result, bool):
                passwd_tab(result)
                continue
            if result == False:
                die()
            if result == True:
                continue
        if tabnum == 1: #Honeypots.
            thelist = ["Pick & copy",
                    "Pick & show",
                    "Bad pick many",
                    "Good pick many",
                    "Add",
                    "Remove"]
            if have_clipboard:
                result = list_choice(2, ysize - 5, thelist, True)
            else:
                result = list_choice(2, ysize - 5, thelist[1:], True)
                if not isinstance(result, bool):
                    result += 1 #There was no first option.
            #Check for booleans last, to avoid misinterpreting 0 and 1.
            if not isinstance(result, bool):
                honeypot_tab(result)
                continue
            if result == False:
                die()
            if result == True:
                continue
        if tabnum == 2: #Help.
            result = roll_text(2, ysize - 5, """
Uppercase W/K, A/H, S/J, D/L will be treated as Page up, Home, Page down, end.

The "change meta-data & update"-button in the "Passwords"-tab:
    1.  If the password was created with the "Add existing"-button: use the
        "change meta-data & update"-button.
    2.  If the password was created with the "Create new"-button: use the
        "update"-button.
    3.  If the minimal required length for the password or the maximal allowed
        length or the allowable characters have changed: use the
        "change meta-data & update"-button.
    
Difference between "Add existing" and "Create new":
    Click on those buttons and see what happens. They are not dangerous.

The "Undo"- and "Redo"-buttons undoes/redoes the LATEST change in the password
tab or the fake-password tab, independent of which tab you're currently in.

The fake-passwords/honey pots are intended to be used as traps to catch
crackers. The "pick"-buttons picks a random fake-password, independent of what
you have selected. You should add fake-passwords such as "password" and
"drowssap".
    """, True)
            if result == False:
                die()
            if result == True:
                continue
        if tabnum == 3: #about.
            result = roll_text(2, ysize - 5, copywrong + "\n" + """
passwdman is a program for remembering and updating passwords. It also
remembers honey-pots (fake-passwords to catch crackers). It has infinite
undo/redo.
 
It can remember old human-generated passwords, create new passwords (digits
or big letters, small letters, digits, underscores and exclamation marks)
with randomized length, update passwords and obviously show and remove
passwords. It can add, remove honey-pots and randomly choose (pick)
honey-pots in two different flavors.
 
It stores the passwords and honey-pots in XML files, so they can be read with
a normal text-editor (normal for unix), depending on the user. The XML files
are not encrypted, so that you don't need to remember an extra password.
  If you want encryption you should encrypt your home-directory.
""", True)
            if result == False:
                die()
            if result == True:
                continue

DEBUG = False
tabnum = 0
have_clipboard = __HAVE_CLIPBOARD__
if have_clipboard:
    import subprocess

if __name__ == "__main__":
    h = api.honeypot()
    p = api.passwd()
    import locale
    locale.setlocale(locale.LC_ALL, '')
    code = locale.getpreferredencoding()
    if DEBUG:
        xsize, ysize = 80, 24
    else:
        tty = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.meta(1)
        tty.keypad(1)
        ysize, xsize = tty.getmaxyx()
        if xsize < 80:
            if xsize < 40 or ysize < 18:
                curses.endwin()
                print("Need at least 40x18 or 80x12 COLSxROWS")
        elif ysize < 12:
            curses.endwin()
            print("Need at least 40x18 or 80x12 COLSxROWS")
    try:
        main()
    except KeyboardInterrupt: #^C
        die()
    except:
        tty.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
        raise