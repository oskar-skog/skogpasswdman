#!/usr/bin/python
copywrong = """
Copyright (c) 2014, Oskar Skog <oskar.skog.finland@gmail.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1.  Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE."""
import passwdmanapi as api
import curses
import math
import os
import tarfile
import sys
import locale

__doc__ = """import passwdmanapi as api
h, p = api.honeypot(), api.passwd()
code = locale.getpreferredencoding()
tty = curses.initscr()
ysize, xsize = tty.getmaxyx()
0 <= tabnum <= 3 (main.__doc__, set_tab.__doc__)
have_clipboard = True or False
See also copy.__doc__, wrap_addch.__doc__, wrap_addstr.__doc__, busy.__doc__,
edit_line.__doc__, edit_num.__doc__, main.__doc__, show_copy_single.__doc__
and center_text.__doc__.
"""

def die():
    """die() - exit curses mode and quit."""
    tty.keypad(0)
    curses.echo()
    curses.nocbreak()
    curses.endwin()
    quit()

def wrap_addch(y, x, c):
    """wrap_addch(y, x, c) - tty.addch(y, x, c), without the evil corner."""
    try:
        tty.addch(y, x, c)
    except:
        #Row 23 column 79 (bottom right) is evil.
        #Usually attempted by center_text().
        pass

def wrap_addstr(y, x, s):
    """wrap_addstr(y, x, s) - encode in Python2, decode in Python3
    tty.addstr(y, x, s)"""
    v, f, f, f, f = sys.version_info
    tty.addstr(y, x, api.b2u3(s))

def center_text(line, text):
    """center_text(line, text) - put text <text> in the center of line <line>.
    Long lines f text will be truncated."""
    assert api.is_anystr(text) and line >= 0 and line < ysize
    start_pos = math.floor((xsize - len(text)) / 2)
    for x in range(xsize):
        if x < start_pos or x >= start_pos + len(text):
            wrap_addch(line, x, ord(" "))
        else:
            wrap_addch(line, x, ord(text[int(x - start_pos)]))

def busy():
    """busy() - ``set busy cursor``"""
    tty.erase()
    center_text(2, "Wait...")
    tty.refresh()

def edit_num(y, num, min_num, max_num, step=1):
    """direction, num = edit_num(y, num, min_num, max_num, step=1)
    num is the starting number/number.
    direction is how the user made this function return.
    direction is either "up", "down" or "back".
    min_num and max_num are num's limits. None = unlimited
    y is the Y-coordinate.
    step is how much to increase/decrease per key-press."""
    assert y >= 0 and y < ysize
    if min_num is not None and max_num is not None:
        assert max_num >= min_num
    while True:
        #Keep num within limits.
        if min_num is not None:
            if num < min_num:
                num = min_num
        if max_num is not None:
            if num > max_num:
                num = max_num
        #Print.
        tty.hline(y, 0, ord(" "), xsize)
        center_text(y, "left - a h home<" + str(num) + ">right + d l end")
        tty.refresh()
        ch = tty.getch()
        if ch in (curses.KEY_LEFT, ord("-"), ord("a"), ord("h")):
            num -= step
            continue
        if ch in (curses.KEY_RIGHT, ord("+"), ord("d"), ord("l")):
            num += step
            continue
        #Increase/decrease 5 * step if there is no limit in that direction.
        if ch in (curses.KEY_HOME, ord("A"), ord("H")):
            if min_num is not None:
                num = min_num
            else:
                num -= step * 5
            continue
        if ch in (curses.KEY_END, ord("D"), ord("L")):
            if max_num is not None:
                num = max_num
            else:
                num += step * 5
            continue
        #Return.
        if ch in (ord(" "), ord("\t"), ord("\n"), curses.KEY_DOWN):
            return "down", num
        if ch == curses.KEY_UP:
            return "up", num
        if ch == 27:
            return "back", num

def edit_line(y, line):
    """direction, line = edit_line(y, line)
    direction is how the user made this function return.
    direction is either "up", "down" or "back".
    line is the line of text that will be/has been edited.
    y is the Y-coordinate."""
    #Unicode string.
    if line is None:
        head_u = api.u("")
    else:
        head_u = api.u(line)
    #Byte string.
    ver, f, f, f, f = sys.version_info
    if ver == 2:
        def mk_head_b():
            return head_u.encode(code)
    else:
        def mk_head_b():
            return list(head_u.encode(code))
    head_b = mk_head_b()
    #Tail.
    tail = api.u("")
    half_len = int(math.floor(xsize / 2))
    while True:
        tty.hline(y, 0, ord(" "), xsize)
        #Print line.
        if len(head_u) < xsize - 1:
            wrap_addstr(y, 0, head_u)
            wrap_addstr(y, len(head_u), tail[:xsize - len(head_u)])
            tty.move(y, len(head_u))
        else:
            wrap_addstr(y, 0, head_u[-half_len:])
            wrap_addstr(y, half_len, tail[:half_len])
            tty.move(y, half_len)
        tty.refresh()
        #Input.
        ch = tty.getch()
        #Navigate in string.
        if ch == curses.KEY_HOME:
            tail = head_u + tail
            head_u = api.u("")
            head_b = mk_head_b()
        elif ch == curses.KEY_END:
            head_u = head_u + tail
            tail = api.u("")
            head_b = mk_head_b()
        elif ch == curses.KEY_LEFT:
            if len(head_u) > 0:
                head_u, tail = head_u[:-1], head_u[-1] + tail
                head_b = mk_head_b()
        elif ch == curses.KEY_RIGHT:
            if len(tail) > 0:
                head_u, tail = head_u + tail[0], tail[1:]
                head_b = mk_head_b()
        #Backspace, delete.
        elif ch == curses.KEY_BACKSPACE:
            if len(head_u) > 0:
                head_u = head_u[:-1]
                head_b = mk_head_b()
        elif ch == curses.KEY_DC:
            if len(tail) > 0:
                tail = tail[1:]
        #Return.
        elif ch in (curses.KEY_DOWN, ord("\t"), ord("\n")):
            return "down", head_u + tail
        elif ch == curses.KEY_UP:
            return "up", head_u + tail
        elif ch == 27:
            return "back", head_u + tail
        elif ch < 256:
            #Loop until multibyte char is done.
            if ver == 2:
                head_b += chr(ch)
                head_u = head_b.decode(code, "ignore")
            else:
                head_b.append(ch)
                head_u = bytes(head_b).decode(code, "ignore")

def after_update(old, new):
    """after_update(old, new)
    Show old and new passwords and let the user copy them to clipboard."""
    tty.erase()
    if (math.ceil(len(old) / xsize + 0.0) +
            math.ceil(len(new) / xsize + 0.0) + 2) > ysize - 2:
        raise api.err_idiot("Not implented!")
    else:
        if have_clipboard:
            center_text(0, "Old: (Press 1 to copy)")
        else:
            center_text(0, "Old:")
        x_pos, y_pos = 0, 1
        for c in old:
            if x_pos >= xsize:
                x_pos = 0
                y_pos += 1
            wrap_addstr(y_pos, x_pos, c)
            x_pos += 1
        if x_pos != 0: #Has it rolled over and increased y_pos?
            y_pos += 1
            x_pos = 0
        if have_clipboard:
            center_text(y_pos, "New: (Press 2 to copy)")
        else:
            center_text(y_pos, "New:")
        y_pos += 1
        for c in new:
            if x_pos >= xsize:
                x_pos = 0
                y_pos += 1
            wrap_addstr(y_pos, x_pos, c)
            x_pos += 1
        center_text(ysize - 1, "Press any other key to finish.")
        tty.refresh()
        while True:
            ch = tty.getch()
            if ch == ord("1") and have_clipboard:
                copy(old)
            elif ch == ord("2") and have_clipboard:
                copy(new)
            else:
                return

def vdictui(arg):
    """ret = vdictui(arg)
    `arg` is a list of dicts. `ret` is a dict.
    
    arg[x]['type'] is optional; a dict without 'type'-key is a synonym
    for 'type': 'space'.
    
    `ret['button']` is either 'back' or the 'name' of a 'button'.
    `ret` also contains key named after the 'name's of 'edit_num's and
    'edit_line's.
    
    Look in `passwd_tab` or `honeypot_tab` for examples.
    
    Values for arg[x]['type']
    =========================
    
        - 'text'        One line of text. Requires key
                        'value': <the actual text>.
        - 'space'       One empty line.
        - 'edit_num'    Number spinner, returns the number in
                        `ret[arg[x]['name']]`.  See also `edit_num`.
                        Other keys
                        ----------
                        
                            - 'value'   Optional; the initial value.
                            - 'name'    Required; the key to store the
                                        value in, in `ret`.
                            - 'min'     Optional; default None.
                            - 'max'     Optional; default None.
                            - 'step'    Optional; default 1.
                            
        - 'edit_line'   One line textbox (input), returns the line in
                        `ret[arg[x]['name']]`.  See also `edit_line`.
                        Other keys
                        ----------
                        
                            - 'value'   Optional; the initial text.
                            - 'name'    Required; the key to store the
                                        value in, in `ret`.
                            
        - 'button'      Button; something that can make
                        ``ret['button'] != 'back'`` True.
                        It will set `ret['button']` to its own 'name'
                        if it is ''clicked''.
                        Other keys
                        ----------
                        
                            - 'value'   Optional; The text that wll be
                                        seen on the screen.
                                        Default: The value of the
                                        'name'-key.
                            - 'name'    Optional; What `ret['button']`
                                        will be set to.
                                        Default: The value of the
                                        'value'-key.
                            
                            If neither of them are specified then both
                            of them will be set to 'OK'.
   
    """
    ret_arg = {}
    where = wrap = 0
    # Initialize:
    #   - Set defaults.
    #   - Set wrap.
    #   - Create the return-variables and set their values.
    for i in arg:
        try:
            iname = i['name']
        except KeyError:
            iname = i['name'] = None
        try:
            itype = i['type']
        except KeyError:
            itype = i['type'] = 'space'
        if itype not in ('space', 'text'):
            wrap += 1
        if itype in ('edit_num', 'edit_line'):
            try:
                ret_arg[iname] = i['value']
            except KeyError:
                # Default values.
                if itype == 'edit_num':
                    ret_arg[iname] = 1
                else:
                    ret_arg[iname] = ""
            if itype == 'edit_num':
                try:
                    forget = i['min']
                except KeyError:
                    i['min'] = None
                try:
                    forget = i['max']
                except KeyError:
                    i['max'] = None
                try:
                    forget = i['step']
                except KeyError:
                    i['step'] = 1
        else:
            # Check the button.
            if iname is None:
                # No name.
                try:
                    i['name'] = i['value']
                except KeyError:
                    # No value.
                    i['name'] = 'OK'
            try:
                forget = i['value']
            except KeyError:
                i['value'] = i['name']
    # Main loop.
    while True:
        tty.erase()
        # Print.
        foobar = 0      # I cannot figure out a good name for this one.
        for y in range(len(arg)):
            # y is both the Y coordinate and the index for arg.
            yname, ytype = arg[y]["name"], arg[y]["type"]
            if ytype == "space":
                pass
            elif ytype == "text":
                center_text(y, arg[y]["value"])
            else:
                assert ytype in ("edit_line", "edit_num", "button")
                if ytype == "edit_line":
                    center_text(y, ret_arg[yname])
                if ytype == "edit_num":
                    center_text(y, str(ret_arg[yname]))
                if ytype == "button":
                    center_text(y, arg[y]["value"])
                    if foobar == where:
                        wrap_addstr(y, 0, "**")
                        wrap_addstr(y, xsize - 2, "**")
                foobar += 1
        tty.refresh()
        # Input.
        foobar = 0
        for y in range(len(arg)):
            yname, ytype = arg[y]["name"], arg[y]["type"]
            if foobar == where:
                direction = None
                if ytype == "edit_line":
                    direction, ret_arg[yname] = edit_line(y, ret_arg[yname])
                if ytype == "edit_num":
                    min_num, max_num = arg[y]["min"], arg[y]["max"]
                    step = arg[y]["step"]
                    direction, ret_arg[yname] = edit_num(y, ret_arg[yname],
                                                    min_num, max_num, step)
                if ytype == "button":
                    ch = tty.getch()
                    if ch == curses.KEY_UP:
                        direction = "up"
                    elif ch in (curses.KEY_DOWN, ord("\t")):
                        direction = "down"
                    elif ch == 27:
                        direction = "back"
                    elif ch in (ord(" "), ord("\n")):
                        ret_arg["button"] = yname
                        return ret_arg
                    elif ch == curses.KEY_PPAGE:
                        where = 0
                        break # Back to main loop.
                    elif ch == curses.KEY_NPAGE:
                        where = wrap - 1
                        break # Back to main loop.
                # Check what value direction has.
                assert direction in ("up", "down", "back", None)
                if direction == "back":
                    ret_arg["button"] = "back"
                    return ret_arg
                if direction == "up":
                    where -= 1
                    break   # Back to main loop.
                if direction == "down":
                    where += 1
                    break   # Back to main loop.
            if ytype in ("button", "edit_num", "edit_line"):
                foobar += 1
        # Keep where in range.
        where %= wrap

def passwd_tab(x):
    """passwd_tab(x)
    x is the action to be performed on a password.
    x begins from 0 (Copy to clipboard), or from 1 (Show password) if not
    have_clipboard.
    See also choice.__doc__ and after_update.__doc__.
    """
    assert x >= 0 and x < 7
    if x < 4 or x == 6:
        selection = choice(False)
        if isinstance(selection, bool):
            assert selection == False
            return      #Will never return True.
    if x == 0:
        # Copy to clipboard.
        assert have_clipboard
        copy(p[selection]["value"])
    if x == 1:
        # Show password.
        tty.erase()
        if len(p[selection]["value"]) > (ysize - 2) * xsize:
            raise api.err_idiot("Not implented!")
        else:
            x_pos = y_pos = 0
            for c in p[selection]["value"]:
                if x_pos >= xsize:
                    x_pos = 0
                    y_pos += 1
                wrap_addstr(y_pos, x_pos, c)
                x_pos += 1
            center_text(ysize - 1, "Press any key.")
            tty.refresh()
            tty.getch()
    if x == 2:
        busy()
        old = p[selection]["value"]
        p.update(selection)
        new = p[selection]["value"]
        after_update(old, new)
    if x == 3:
        #Change meta-data and update.
        if p[selection]["meta"]["type"] in ("10", "64"):
            minlen = int(p[selection]["meta"]["minlength"])
            maxlen = int(p[selection]["meta"]["maxlength"])
        else:
            assert p[selection]["meta"]["type"] == "human"
            minlen = maxlen = 8
        result = vdictui([
            {
                'type': 'text',
                'value': 'Minimal required length'
            }, {
                'type': 'edit_num',
                'name': 'min',
                'value': minlen,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': 'Maximal allowed length'
            }, {
                'type': 'edit_num',
                'name': 'max',
                'value': maxlen,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': "Big & small letters, digits, '!', '_'"
            }, {
                'type': 'button',
                'name': '64',
                'value': 'OK'
            }, {}, {
                'type': 'text',
                'value': 'Digits only'
            }, {
                'type': 'button',
                'name': '10',
                'value': 'OK'
            }])
        if result["button"] == "back":
            return
        busy()
        old = p[selection]["value"]
        #BUG TODO stop user from having minlength > maxlength.
        p.update_meta(selection, result["button"],
                                        result["min"], result["max"])
        new = p[selection]["value"]
        after_update(old, new)
    if x == 4:
        result = vdictui([
            {
                'type': 'text',
                'value': 'What is the password for?'
            }, {
                'type': 'edit_line',
                'name': 'name'
            }, {}, {
                'type': 'text',
                'value': 'What is the password?'
            }, {
                'type': 'edit_line',
                'name': 'value'
            }, {}, {
                'type': 'button'
            }])
        if result["button"] == "back":
            return
        p.add_nometa(result["name"], result["value"])
    if x == 5:
        #Create new.
        result = vdictui([
            {
                'type': 'text',
                'value': 'What is the password for?'
            }, {
                'type': 'edit_line',
                'name': 'name'
            }, {}, {
                'type': 'text',
                'value': 'Minimal required length'
            }, {
                'type': 'edit_num',
                'name': 'minlen',
                'value': 8,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': 'Maximal allowed length'
            }, {
                'type': 'edit_num',
                'name': 'maxlen',
                'value': 8,
                'min': 1
            }, {}, {
                'type': 'text',
                'value': "Big & small letters, digits, '!', '_'"
            }, {
                'type': 'button',
                'name': '64',
                'value': 'OK'
            }, {}, {
                'type': 'text',
                'value': 'Digits only'
            }, {
                'type': 'button',
                'name': '10',
                'value': 'OK'
            }])
        if result == "back":
            return
        busy()
        #BUG TODO stop user from having minlength > maxlength.
        p.add(result["name"], None, result["button"], result["minlen"],
                                                        result["maxlen"])
    if x == 6:
        # Remove.
        p.remove(selection)

def show_copy_single(s):
    """show_copy_single(s)
    Show a string and let the user copy it to clipboard."""
    if len(s) > (ysize - 3) * xsize:
        raise api.err_idiot("Not implented!")
    else:
        tty.erase()
        x_pos = y_pos = 0
        for c in s:
            if x_pos >= xsize:
                x_pos = 0
                y_pos += 1
            wrap_addstr(y_pos, x_pos, c)
            x_pos += 1
        if have_clipboard:
            center_text(ysize - 2, "Press 1 to copy.")
            center_text(ysize - 1, "Press any other key to finish.")
        else:
            center_text(ysize - 1, "Press any key to finish.")
        tty.refresh()
        while True:
            ch = tty.getch()
            if ch == ord("1") and have_clipboard:
                copy(s)
            else:
                break

def honeypot_tab(x):
    """honeypot_tab(x)
    x is the action to be performed on a honeypot.
    x begins from 0 (Pick & copy), or from 1 (Pick & show) if not
    have_clipboard.
    See also choice.__doc__"""
    assert x >= 0 and x < 6
    if x == 0:
        #Pick & copy.
        assert have_clipboard
        copy(h.pick())
    if x == 1:
        #Pick & show.
        tty.erase()
        s = h.pick()
        if len(s) > (ysize - 2) * xsize:
            raise api.err_idiot("Not implented!")
        else:
            x_pos = y_pos = 0
            for c in s:
                if x_pos >= xsize:
                    x_pos = 0
                    y_pos += 1
                wrap_addstr(y_pos, x_pos, c)
                x_pos += 1
            center_text(ysize - 1, "Press any key.")
            tty.refresh()
            tty.getch()
    if x == 2:
        # Bad pick many.
        result = vdictui([
            {
                'type': 'text',
                'value': 'How many?'
            }, {
                'type': 'edit_num',
                'name': 'num',
                'min': 1,
                'max': len(h)
            }, {}, {
                'type': 'text',
                'value': 'Separate them with?'
            }, {
                'type': 'edit_line',
                'name': 'sep',
                'value': ','
            }, {}, {
                'type': 'button'
            }])
        if result["button"] == "back":
            return
        busy()
        s = h.pick(result["num"], result["sep"])
        show_copy_single(s)
    if x == 3:
        # Good pick many.
        ui_result = vdictui([
            {
                'type': 'text',
                'value': 'How many?'
            }, {
                'type': 'edit_num',
                'name': 'num',
                'min': 1,
                'max': len(h)
            }, {}, {
                'type': 'button'
            }])
        if ui_result["button"] == "back":
            return
        busy()
        result = h.pickl(ui_result["num"])
        for s in result:
            show_copy_single(s)
    if x == 4:
        # Add.
        result = vdictui([
            {
                'type': 'text',
                'value': 'What is the fake password?'
            }, {
                'type': 'edit_line',
                'name': 'line'
            }, {}, {
                'type': 'button'
            }])
        if result["button"] == "back":
            return
        h.add(result["line"])
    if x == 5:
        #Remove.
        selection = choice(True)
        if isinstance(selection, bool):
            assert selection == False
            return      #Will never return True.
        h.remove(selection)

def copy(x):
    """copy(s)
    copy s to the clipboard.
    Not written by me."""
    # "primary":
    xsel_proc = subprocess.Popen(['xsel', '-pi'], stdin=subprocess.PIPE)
    xsel_proc.communicate(api.b(x))
    # "clipboard":
    xsel_proc = subprocess.Popen(['xsel', '-bi'], stdin=subprocess.PIPE)
    xsel_proc.communicate(api.b(x))

def set_tab(direction):
    """set_tab(direction)
    Move to another tab in main().
    0 <= direction <= 3 or direction in ("<", ">")"""
    global tabnum
    assert api.is_anystr(direction)
    if direction == ">":
        tabnum += 1
    elif direction == "<":
        tabnum -= 1
    elif direction == "first":
        tabnum = 0
    elif direction == "last":
        tabnum = num_tabs - 1
    else:
        raise api.err_idiot("What the fuck does that mean?")
    if tabnum < 0:
        tabnum = num_tabs - 1
    if tabnum >= num_tabs:
        tabnum = 0

def choice(honeypot):
    """choice(honeypot)
    Return index for p if honeypot == False.
    Return index for h if honeypot == True.
    Returns False if the user cancels."""
    tty.erase()
    thelist = []
    if honeypot:
        center_text(0, "Please select fake-password.")
        for x in h:
            thelist.append(x)
    else:
        center_text(0, "Please select password.")
        for x in p:
            thelist.append(x["name"])
    if len(thelist) > 0:
        #I know this will ask the user even if there only is one choice, but
        #it will show which password/honeypot the only one is.
        return list_choice(1, ysize - 1, thelist)
    else:
        return False

def zxcv_handler(x):
    """zxcv_handler(x)
    x is whatever tty.getch() has returned.
    Handle undo/redo/make backup/clear clipboard."""
    if x in (ord("z"), ord("Z"), ord("b"), ord("B")):
        api.undo(p, h)
    if x in (ord("x"), ord("X"), ord("n"), ord("N")):
        api.redo(p, h)
    if x in (ord("c"), ord("C"), ord("m"), ord("M")):
        result = vdictui([
            {
                'type': 'text',
                'value': 'File name (.tar.gz)'
            }, {
                'type': 'edit_line',
                'name': 'tarball_name'
            }, {}, {
                'type': 'button'
            }])
        if result["button"] == "back":
            return
        tarball_name = result['tarball_name']
        try:    #Normal suffix?
            test = tarball_name[-4:] == ".tgz"
            if not test:
                test = tarball_name[-7:] == ".tar.gz"
        except:
            test = False
        if not test:
            tty.erase()
            center_text(0, "Append suffix (Y/N)?")
            tty.refresh()
            while True:
                ch = tty.getch()
                if ch in (ord("y"), ord("Y")):
                    tarball_name += ".tar.gz"
                    break
                if ch in (ord("n"), ord("N")):
                    break
        old_dir = os.getcwd()
        os.chdir(os.path.expanduser("~"))
        tarball = tarfile.open(os.path.expanduser(tarball_name), "w:gz")
        tarball.add(".passwdman")
        tarball.close()
        os.chdir(old_dir)
    if have_clipboard and x in (ord("v"), ord("V"), ord(",")):
        copy("EMPTY")

def list_choice(ypos, yspace, thelist, ct=False):
    """list_choice(ypos, yspace, thelist, ct=False)
    thelist is a list of strings (buttons).
    It can change tabs if ct == True.
    Returns True if the user changed tab.
    Returns False if the user canceled.
    Returns an index to thelist if the user has `clicked` on one of the
    buttons.
    ypos is the Y-coordinate.
    yspace is the number of rows list_choice() will eat of the screen.
    See also zxcv_handler.__doc__"""
    assert len(thelist) > 0
    xspace = 0
    for x in thelist:
        if len(x) > xspace:
            xspace = len(x)
    xspace += 4         # [**]
    assert yspace >= 7 and xspace <= xsize
    center_text(ypos, "Page-up up w k 8")
    center_text(ypos + 1, "Choose with space, tab or enter")
    center_text(ypos + 2, "or escape to cancel.")
    center_text(ypos + yspace - 1, "Page-down down s j 2")
    # The size of a ``page``.
    page = yspace - 6
    # Leftover columns on the right.
    x_leftover = xsize - xspace
    if x_leftover >= 8: # Enough room for "<-Choose"?
        show_arrow = True
    else:
        show_arrow = False
    # The currently selected button.
    choice = 0
    size = len(thelist)
    while True:
        # Draw.
        for i in range(page):
            # Offset of the current page in the list.
            offset = choice - choice%page
            button_listpos = offset + i
            button_ypos = i + ypos + 4
            # Surrounding brackets.
            wrap_addch(button_ypos, 0, ord("["))
            wrap_addch(button_ypos, xspace - 1, ord("]"))
            # Past end?
            if button_listpos >= size:
                # Put empty.
                tty.hline(button_ypos, 0, ord("#"), xspace)
                tty.hline(button_ypos, xspace, ord(" "), x_leftover)
            else:
                # Put line.
                if choice % page == i:  #Selected?
                    wrap_addch(button_ypos, 1, ord("*"))
                    wrap_addch(button_ypos, xspace - 2, ord("*"))
                    if show_arrow:
                        wrap_addstr(button_ypos, xspace, "<-Choose")
                else:
                    if show_arrow:
                        tty.hline(button_ypos, xspace, 32, x_leftover)
                    wrap_addch(button_ypos, 1, ord(" "))
                    wrap_addch(button_ypos, xspace - 2, ord(" "))
                #Print the characters.
                for x in range(2, xspace - 2):
                    # Print the buttons.
                    if x - 2 >= len(thelist[button_listpos]):
                        wrap_addch(button_ypos, x, ord(" "))
                    else:
                        wrap_addstr(button_ypos, x,
                                            thelist[button_listpos][x - 2])
        # Print the 'rollability-indicators'.
        if offset - page < 0:
            tty.hline(ypos + 3, 0, ord("-"), xspace)
        else:
            tty.hline(ypos + 3, 0, ord("^"), xspace)
        if offset + page > len(thelist) - 1:
            tty.hline(ypos + yspace - 2, 0, ord("-"), xspace)
        else:
            tty.hline(ypos + yspace - 2, 0, ord("v"), xspace)
        tty.refresh()
        # Handle input.
        ch = tty.getch()
        if ch == 27:    #Escape
            return False
        # Up/down.
        if ch in (ord("8"), ord("w"), ord("k"), curses.KEY_UP):
            choice -= 1
        if ch in (ord("2"), ord("s"), ord("j"), curses.KEY_DOWN):
            choice += 1
        if ch in (ord("W"), ord("K"), curses.KEY_PPAGE):
            choice -= page
        if ch in (ord("S"), ord("J"), curses.KEY_NPAGE):
            choice += page
        # Don't let choice be out of range
        if choice >= len(thelist):
            choice = len(thelist) - 1
        if choice < 0:
            choice = 0
        # Choose.
        if ch in (ord("\t"), ord(" "), ord("\n")):
            return choice
        zxcv_handler(ch)
        if ct:  # Change tab?
            if ch in (ord("4"), ord("a"), ord("h"), curses.KEY_LEFT):
                set_tab("<")
            elif ch in (ord("6"), ord("d"), ord("l"), curses.KEY_RIGHT):
                set_tab(">")
            elif ch in (ord("A"), ord("H"), curses.KEY_HOME):
                set_tab("first")
            elif ch in (ord("D"), ord("L"), curses.KEY_END):
                set_tab("last")
            else:
                continue
            return True

def roll_text(ypos, yspace, thetext, ct=False):
    """roll_text(ypos, yspace, thetext, ct = False)
    Show a large amount of text on the screen.
    It can change tabs if ct == True.
    Returns True if the user changed tab.
    Returns False if the user canceled.
    ypos is the Y-coordinate.
    yspace is the number of rows roll_text() will eat of the screen.
    See also zxcv_handler.__doc__"""
    thelines = thetext.split("\n")
    page = yspace - 4
    linepos = 0
    center_text(ypos, "Page-up up W K 8")
    center_text(ypos + yspace - 1, "Page-down down S J 2")
    while True:
        #Print.
        for i in range(page):
            for x in range(xsize):
                try:
                    c = ord(thelines[i + linepos][x])
                except:
                    c = ord(" ")
                wrap_addch(i + ypos + 2, x, c)
        if linepos < 1:
            tty.hline(ypos + 1, 0, ord("-"), xsize)
        else:
            tty.hline(ypos + 1, 0, ord("^"), xsize)
        if linepos + page > len(thelines):
            tty.hline(ypos + yspace - 2, 0, ord("-"), xsize)
        else:
            tty.hline(ypos + yspace - 2, 0, ord("v"), xsize)
        tty.refresh()
        ch = tty.getch()
        if ct:  #Change tab?
            if ch in (ord("4"), ord("a"), ord("h"), curses.KEY_LEFT):
                set_tab("<")
                return True
            if ch in (ord("6"), ord("d"), ord("l"), curses.KEY_RIGHT):
                set_tab(">")
                return True
            if ch in (ord("A"), ord("H"), curses.KEY_HOME):
                set_tab("first")
                return True
            if ch in (ord("D"), ord("L"), curses.KEY_END):
                set_tab("last")
                return True
        if ch == 27:
            return False
        oldpos = linepos
        if ch in (ord("w"), ord("k"), ord("8"), curses.KEY_UP):
            linepos -= 1
        if ch in (ord("s"), ord("j"), ord("2"), curses.KEY_DOWN):
            linepos += 1
        if ch in (ord("W"), ord("K"), curses.KEY_PPAGE):
            linepos -= page
        if ch in (ord("S"), ord("J"), curses.KEY_NPAGE):
            linepos += page
        zxcv_handler(ch)
        if linepos < 0 or linepos >= len(thelines):
            linepos = oldpos

def hdictui(arg):
    global tabnum
    global num_tabs
    tabnum = num_tabs = 0
    tab_names = [[], []]
    for i in arg:
        num_tabs += 1
        tab_names[0].append(i['name'].lower())
        tab_names[1].append(i['name'].upper())
    while True:
        # Tab headers.
        tty.erase()
        if xsize >= 80:
            s = "Home left a h 4"
            wrap_addstr(0, 0, s)
            wrap_addstr(0, len(s), "::")
            x_pos = len(s) + 2
            for i in range(num_tabs):
                if i == tabnum:
                    wrap_addstr(0, x_pos, tab_names[1][i])
                else:
                    wrap_addstr(0, x_pos, tab_names[0][i])
                x_pos += len(tab_names[0][i])
                wrap_addstr(0, x_pos, ":")
                x_pos += 1
            wrap_addstr(0, x_pos, ":6 l d right end")
            # zxcv
            if have_clipboard:
                wrap_addstr(ysize - 2, 0, "(z/b) undo : (x/n) redo : (c/m)" +
                    " Make backup : (v/,) Clear clipboard : (^C) quit")
            else:
                wrap_addstr(ysize - 2, 0, "(z/b) undo : (x/n) redo : (c/m)" +
                    " Make backup : (^C) quit")
            # Lines.
            tty.hline(1, 0, ord("="), xsize)
            tty.hline(ysize - 3, 0, ord("="), xsize)
            tty.refresh()
        else:
            pass    #TODO
        # Tab content.
        the_dict = arg[tabnum]
        the_type = the_dict['type']
        if the_type == 'list_choice':
            result = list_choice(2, ysize - 5, the_dict['choices'], True)
            if not isinstance(result, bool):
                # Call custom function with an alias for the result.
                the_dict['function'](the_dict['aliases'][result])
        elif the_type == 'roll_text':
            roll_text(2, ysize - 5, the_dict['text'], True)
        else:
            assert False, "Odd type '{0}' in {1}".format(the_type, the_dict)

def main():
    """See list_choice.__doc__, passwd_tab.__doc__, honeypot_tab.__doc__,
    roll_text.__doc__ and die.__doc__."""
    help_text = """
Uppercase W/K, A/H, S/J, D/L will be treated as Page up, Home, Page down, end.

The "change meta-data & update"-button in the "Passwords"-tab:
    1.  If the password was created with the "Add existing"-button: use the
        "change meta-data & update"-button.
    2.  If the password was created with the "Create new"-button: use the
        "update"-button.
    3.  If the minimal required length for the password or the maximal allowed
        length or the allowable characters have changed: use the
        "change meta-data & update"-button.
    
Difference between "Add existing" and "Create new":
    Click on those buttons and see what happens. They are not dangerous.

The "Undo"- and "Redo"-buttons undoes/redoes the LATEST change in the password
tab or the fake-password tab, independent of which tab you're currently in.

The fake-passwords/honey pots are intended to be used as traps to catch
crackers. The "pick"-buttons picks a random fake-password, independent of what
you have selected. You should add fake-passwords such as "password" and
"drowssap".
"""
    about_text = """
passwdman is a program for remembering and updating passwords. It also
remembers honey-pots (fake-passwords to catch crackers). It has infinite
undo/redo.
 
It can remember old human-generated passwords, create new passwords (digits
or big letters, small letters, digits, underscores and exclamation marks)
with randomized length, update passwords and obviously show and remove
passwords. It can add, remove honey-pots and randomly choose (pick)
honey-pots in two different flavors.
 
It stores the passwords and honey-pots in XML files, so they can be read with
a normal text-editor (normal for unix), depending on the user. The XML files
are not encrypted, so that you don't need to remember an extra password.
  If you want encryption you should encrypt your home-directory.
"""
    passwd_choices = ["Copy to clipboard",
                      "Show password",
                      "Update",
                      "Change meta-data & update",
                      "Add existing",
                      "Create new",
                      "Remove"]
    honeypot_choices = ["Pick & copy",
                        "Pick & show",
                        "Bad pick many",
                        "Good pick many",
                        "Add",
                        "Remove"]
    # Use numbers in order to not break passwd_tab and honeypot_tab.
    passwd_aliases = [0, 1, 2, 3, 4, 5, 6]
    honeypot_aliases = [0, 1, 2, 3, 4, 5]
    # I'm lucky. The copy-only choices are on the top.
    if not have_clipboard:
        passwd_choices = passwd_choices[1:]
        passwd_aliases = passwd_aliases[1:]
        honeypot_choices = honeypot_choices[1:]
        honeypot_aliases = honeypot_aliases[1:]
    hdictui([
        {
            'name': 'Passwords',
            'type': 'list_choice',
            'choices': passwd_choices,
            'aliases': passwd_aliases,
            'function': passwd_tab
        }, {
            'name': 'Fake passwords',
            'type': 'list_choice',
            'choices': honeypot_choices,
            'aliases': honeypot_aliases,
            'function': honeypot_tab
        }, {
            'name': 'Help',
            'type': 'roll_text',
            'text': help_text
        }, {
            'name': 'About',
            'type': 'roll_text',
            'text': copywrong + about_text
        }])

DEBUG = False
tabnum = 0
have_clipboard = __HAVE_CLIPBOARD__
if have_clipboard:
    import subprocess

if __name__ == "__main__":
    h = api.honeypot()
    p = api.passwd()
    locale.setlocale(locale.LC_ALL, '')
    code = locale.getpreferredencoding()
    if DEBUG:
        xsize, ysize = 80, 24
    else:
        tty = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.meta(1)
        tty.keypad(1)
        ysize, xsize = tty.getmaxyx()
        if xsize < 80:
            if xsize < 40 or ysize < 18:
                curses.endwin()
                print("Need at least 40x18 or 80x12 COLSxROWS")
        elif ysize < 12:
            curses.endwin()
            print("Need at least 40x18 or 80x12 COLSxROWS")
    try:
        main()
    except KeyboardInterrupt: #^C
        die()
    except:
        tty.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
        raise