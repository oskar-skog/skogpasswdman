#!/usr/bin/python
copywrong = """
Copyright (c) 2014, Oskar Skog <oskar.skog.finland@gmail.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1.  Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE."""
import skogpasswdmanapi as api
import curses
import math
import os
import tarfile
import sys
import locale
import unicodedata
import traceback

__doc__ = """

import skogpasswdmanapi as api

h, p = api.honeypot(), api.passwd()
code = locale.getpreferredencoding()
tty = curses.initscr()
ysize, xsize = tty.getmaxyx()


have_clipboard = __HAVE_CLIPBOARD__     # configure -> make -> sed
#have_clipboard = True
#have_clipboard = False
DEBUG = False

if DEBUG:
    In debug mode there will be a 80x22 virtual screen and a
    cursor-coordinate.
    wrap_refresh() will print them.
    The debug-mode is not Unicode-friendly with Python 2.x.
    
    debug_curses_cursor = y, x
    int, int or None, None
    debug_curses_screen[y][x]['key'] = ord(c)
    list < list < dict < int
    
    0 <= y <= 19
    0 <= x <= 79
    
    debug_curses_cursor == None, None:
        Unknown. Only wrap_move() can set the cursor to a known value.

"""

class retry_error(Exception):
    '''class retry_error(Exception)
    Understood by list_choice_to_vdictui().
    Run the user-interface code again.
    '''
    pass

def die():
    """die() - exit curses mode and quit.
    Affected by DEBUG.
    """
    if not DEBUG:
        tty.keypad(0)
        curses.echo()
        curses.nocbreak()
        curses.endwin()
    else:
        print('Killed curses')
    quit()

def wrap_addch(y, x, c):
    """wrap_addch(y, x, c)
    tty.addch(y, x, c), without the evil corner.
    Affected by DEBUG."""
    if not DEBUG:
        try:
            tty.addch(y, x, c)
        except:
            # Row 23 column 79 (bottom right) is evil.
            # Usually attempted by center_text().
            pass
    else:
        global debug_curses_cursor
        global debug_curses_screen
        debug_curses_cursor = None, None
        print("addch {0}, {1}: '{2}'".format(y, x, chr(c)))
        debug_curses_screen[y][x] = {'key': c}

def wrap_addstr(y, x, s):
    """wrap_addstr(y, x, s) - encode in Python2, decode in Python3
    tty.addstr(y, x, s)
    Affected by DEBUG.
    """
    s2 = api.b2u3(s)
    if not DEBUG:
        tty.addstr(y, x, s2)
    else:
        global debug_curses_cursor
        global debug_curses_screen
        debug_curses_cursor = None, None
        print("addstr {0}, {1}: '{2}'".format(y, x, s2))
        for c in api.u(s):
            debug_curses_screen[y][x] = {'key': ord(c)}
            x += 1

def wrap_hline(y, x, c, length):
    """wrap_hline(y, x, c, length)
    tty.hline(y, x, c, length)
    Affected by DEBUG.
    """
    if not DEBUG:
        tty.hline(y, x, c, length)
    else:
        global debug_curses_cursor
        global debug_curses_screen
        debug_curses_cursor = None, None
        print("hline {0}, {1}: {2}*'{3}'".format(y, x, length, chr(c)))
        for x2 in range(length):
            debug_curses_screen[y][x + x2] = {'key': c}

def wrap_refresh():
    """wrap_refresh()
    tty.refresh()
    Affected by DEBUG.
    """
    if not DEBUG:
        tty.refresh()
    else:
        for y in range(20):
            line = []
            for x in range(80):
                line.append(uchr(debug_curses_screen[y][x]['key']))
            print(''.join(line))
        print('{0}'.format(debug_curses_cursor))

def wrap_getch():
    """wrap_getch()
    tty.getch()
    Affected by DEBUG.
    """
    if not DEBUG:
        return tty.getch()
    else:
        print('getch')
        print('Enter OR character + enter OR integer; >=2 characters + enter')
        x = sys.stdin.readline()
        if len(x) > 2:
            return int(x)
        elif x == '\n':
            return 10
        else:
            return ord(x[0])

def wrap_erase():
    """wrap_erase()
    tty.erase()
    Affected by DEBUG.
    """
    if not DEBUG:
        tty.erase()
    else:
        global debug_curses_cursor
        global debug_curses_screen
        print('erase')
        u = ord(' ')
        for y in range(20):
            for x in range(80):
                debug_curses_screen[y][x] = {'key': u}
        debug_curses_cursor = None, None

def wrap_move(y, x):
    """wrap_move(y, x)
    tty.move(y, x)
    Affected by DEBUG.
    """
    if not DEBUG:
        tty.move(y, x)
    else:
        global debug_curses_cursor
        debug_curses_cursor = y, x
        print('move {0}, {1}'.format(y, x))

def center_text(line, text):
    """center_text(line, text) - put text <text> in the center of line <line>.
    Long lines f text will be truncated.
    Affected by DEBUG.
    """
    assert api.is_anystr(text) and line >= 0 and line < ysize
    if DEBUG:
        print("center_text {0}, '{1}'".format(line, text))
    start_pos = math.floor((xsize - len(text)) / 2)
    for x in range(xsize):
        if x < start_pos or x >= start_pos + len(text):
            wrap_addch(line, x, ord(" "))
        else:
            wrap_addch(line, x, ord(text[int(x - start_pos)]))

def rli_progressbar():
    """rli_progressbar()
    Erase screen and return a `api.progress_bar` object.
    """
    wrap_erase()
    center_text(2, "Wait...")
    wrap_refresh()
    return api.progress_bar(1.0, 100.0, rli_progress)

def rli_progress(percent, data):
    """rli_progress(percent, data)
    Used by the object returned by `rli_progressbar`.
    """
    center_text(3, "{0}%".format(int(math.floor(percent))))
    length = float(xsize - 2)
    wrap_addch(4, 0, ord("["))
    wrap_addch(4, xsize - 1, ord("]"))
    try:
        wrap_hline(4, 1, ord("*"), int(math.floor(percent/100.0 * length)))
    except:
        pass
    wrap_refresh()

def pebkac(complaint):
    """pebkac(complaint)
    Complain about I-D-10-T errors.
    """
    wrap_erase()
    center_text(0, "ERROR")
    center_text(2, "Problem exist between keyboard and chair.")
    
    pos = 4
    for line in complaint.split('\n'):
        center_text(pos, line)
        pos += 1
    
    center_text(ysize - 1, "Press any key to retry, go crazy or crash.")
    wrap_refresh()
    wrap_getch()

def common_ct_handler(ch):
    '''common_ct_handler(ch)
    
    Returns True if the user changed tab.
    
    `ch`        Character; wrap_getch().
    `ct`        Change tab.
    
    >>> if common_ct_handler(ch) and ct:
    ...     # The user changed tab.
    ...     pass
    ... 
    >>> 
    '''
    ret = True
    if ch in (ord("4"), ord("a"), ord("h"), curses.KEY_LEFT):
        set_tab("<")
    elif ch in (ord("6"), ord("d"), ord("l"), curses.KEY_RIGHT):
        set_tab(">")
    elif ch in (ord("A"), ord("H"), curses.KEY_HOME):
        set_tab("first")
    elif ch in (ord("D"), ord("L"), curses.KEY_END):
        set_tab("last")
    else:
        ret = False
    return ret

def common_updown_handler(ch, page):
    '''common_updown_handler(ch, page)
    
    Returns an integer for how many <whatever> down the user wants to
    go.
    
    `ch`        Character; wrap_getch().
    `page`      Page-size
    
    Returns
    -------
    
        0       Don't move.
        +1      Down.
        -1      Up.
        +page   Page down.
        -page   Page up.
    '''
    if ch in (ord("8"), ord("w"), ord("k"), curses.KEY_UP):
        return -1
    if ch in (ord("2"), ord("s"), ord("j"), curses.KEY_DOWN):
        return 1
    if ch in (ord("W"), ord("K"), curses.KEY_PPAGE):
        return -page
    if ch in (ord("S"), ord("J"), curses.KEY_NPAGE):
        return page
    return 0

def edit_num(y, num, min_num, max_num, step=1):
    """direction, num = edit_num(y, num, min_num, max_num, step=1)
    num is the starting number/number.
    direction is how the user made this function return.
    direction is either "up", "down" or "back".
    min_num and max_num are num's limits. None = unlimited
    y is the Y-coordinate.
    step is how much to increase/decrease per key-press."""
    assert y >= 0 and y < ysize
    if min_num is not None and max_num is not None:
        assert max_num >= min_num
    while True:
        # Keep num within limits.
        if min_num is not None:
            if num < min_num:
                num = min_num
        if max_num is not None:
            if num > max_num:
                num = max_num
        # Print.
        wrap_hline(y, 0, ord(" "), xsize)
        center_text(y, "(/) Flip sign.  left - a h home<" +
                                                str(num) +
                       ">right + d l end.  (Del) zero.")
        wrap_refresh()
        ch = wrap_getch()
        if ch in (curses.KEY_LEFT, ord("-"), ord("a"), ord("h")):
            num -= step
            continue
        if ch in (curses.KEY_RIGHT, ord("+"), ord("d"), ord("l")):
            num += step
            continue
        # Increase/decrease 5 * step if there is no limit in that direction.
        if ch in (curses.KEY_HOME, ord("A"), ord("H")):
            if min_num is not None:
                num = min_num
            else:
                num -= step * 5
            continue
        if ch in (curses.KEY_END, ord("D"), ord("L")):
            if max_num is not None:
                num = max_num
            else:
                num += step * 5
            continue
        # Quick editing.
        for i in range(48, 58):
            if ch == i:
                num = int(str(num) + chr(ch))
                break
        if ch == curses.KEY_BACKSPACE:
            try:
                num = int(str(num)[:-1])
            except ValueError:
                pass
        if ch == ord('/'):
            num = -num
        if ch == curses.KEY_DC:
            num = 0
        # Return.
        if ch in (ord(" "), ord("\t"), ord("\n"), curses.KEY_DOWN):
            return "down", num
        if ch == curses.KEY_UP:
            return "up", num
        if ch == 27:
            return "back", num

def edit_line(y, line):
    """direction, line = edit_line(y, line)
    direction is how the user made this function return.
    direction is either "up", "down" or "back".
    line is the line of text that will be/has been edited.
    y is the Y-coordinate."""
    #Unicode string.
    if line is None:
        head_u = api.u("")
    else:
        head_u = api.u(line)
    #Byte string.
    ver, f, f, f, f = sys.version_info
    if ver == 2:
        def mk_head_b():
            return head_u.encode(code)
    else:
        def mk_head_b():
            return list(head_u.encode(code))
    head_b = mk_head_b()
    #Tail.
    tail = api.u("")
    half_len = int(math.floor(xsize / 2))
    while True:
        wrap_hline(y, 0, ord(" "), xsize)
        #Print line.
        if len(head_u) < xsize - 1:
            wrap_addstr(y, 0, head_u)
            wrap_addstr(y, len(head_u), tail[:xsize - len(head_u)])
            wrap_move(y, len(head_u))
        else:
            wrap_addstr(y, 0, head_u[-half_len:])
            wrap_addstr(y, half_len, tail[:half_len])
            wrap_move(y, half_len)
        wrap_refresh()
        #Input.
        ch = wrap_getch()
        #Navigate in string.
        if ch == curses.KEY_HOME:
            tail = head_u + tail
            head_u = api.u("")
            head_b = mk_head_b()
        elif ch == curses.KEY_END:
            head_u = head_u + tail
            tail = api.u("")
            head_b = mk_head_b()
        elif ch == curses.KEY_LEFT:
            if len(head_u) > 0:
                head_u, tail = head_u[:-1], head_u[-1] + tail
                head_b = mk_head_b()
        elif ch == curses.KEY_RIGHT:
            if len(tail) > 0:
                head_u, tail = head_u + tail[0], tail[1:]
                head_b = mk_head_b()
        #Backspace, delete.
        elif ch == curses.KEY_BACKSPACE:
            if len(head_u) > 0:
                head_u = head_u[:-1]
                head_b = mk_head_b()
        elif ch == curses.KEY_DC:
            if len(tail) > 0:
                tail = tail[1:]
        #Return.
        elif ch in (curses.KEY_DOWN, ord("\t"), ord("\n")):
            return "down", head_u + tail
        elif ch == curses.KEY_UP:
            return "up", head_u + tail
        elif ch == 27:
            return "back", head_u + tail
        elif ch < 256:
            #Loop until multibyte char is done.
            if ver == 2:
                head_b += chr(ch)
                head_u = head_b.decode(code, "ignore")
            else:
                head_b.append(ch)
                head_u = bytes(head_b).decode(code, "ignore")

def after_update(old, new):
    """after_update(old, new)
    Show old and new passwords and let the user copy them to clipboard.
    """
    show_copy_single(old, "--Old--")
    show_copy_single(new, "--New--")

def vdictui(arg):
    """ret = vdictui(arg)
    `arg` is a list of dicts. `ret` is a dict.
    
    arg[x]['type'] is optional; a dict without 'type'-key is a synonym
    for 'type': 'space'.
    
    `ret['button']` is either 'back' or the 'name' of a 'button'.
    `ret` also contains key named after the 'name's of 'edit_num's and
    'edit_line's.
    
    Look in `passwd_tab` or `honeypot_tab` for examples.
    
    Values for arg[x]['type']
    =========================
    
        - 'text'        One line of text. Requires key
                        'value': <the actual text>.
        - 'space'       One empty line.
        - 'edit_num'    Number spinner, returns the number in
                        `ret[arg[x]['name']]`.  See also `edit_num`.
                        Other keys
                        ----------
                        
                            - 'value'   Optional; the initial value.
                            - 'name'    Required; the key to store the
                                        value in, in `ret`.
                            - 'min'     Optional; default None.
                            - 'max'     Optional; default None.
                            - 'step'    Optional; default 1.
                            
        - 'edit_line'   One line textbox (input), returns the line in
                        `ret[arg[x]['name']]`.  See also `edit_line`.
                        Other keys
                        ----------
                        
                            - 'value'   Optional; the initial text.
                            - 'name'    Required; the key to store the
                                        value in, in `ret`.
                            
        - 'button'      Button; something that can make
                        ``ret['button'] != 'back'`` True.
                        It will set `ret['button']` to its own 'name'
                        if it is ''clicked''.
                        Other keys
                        ----------
                        
                            - 'value'   Optional; The text that wll be
                                        seen on the screen.
                                        Default: The value of the
                                        'name'-key.
                            - 'name'    Optional; What `ret['button']`
                                        will be set to.
                                        Default: The value of the
                                        'value'-key.
                            
                            If neither of them are specified then both
                            of them will be set to 'OK'.
   
    """
    ret_arg = {}
    where = wrap = 0
    # Initialize:
    #   - Set defaults.
    #   - Set wrap.
    #   - Create the return-variables and set their values.
    for i in arg:
        try:
            iname = i['name']
        except KeyError:
            iname = i['name'] = None
        try:
            itype = i['type']
        except KeyError:
            itype = i['type'] = 'space'
        if itype not in ('space', 'text'):
            wrap += 1
        if itype in ('edit_num', 'edit_line'):
            try:
                ret_arg[iname] = i['value']
            except KeyError:
                # Default values.
                if itype == 'edit_num':
                    ret_arg[iname] = 1
                else:
                    ret_arg[iname] = ""
            if itype == 'edit_num':
                try:
                    forget = i['min']
                except KeyError:
                    i['min'] = None
                try:
                    forget = i['max']
                except KeyError:
                    i['max'] = None
                try:
                    forget = i['step']
                except KeyError:
                    i['step'] = 1
        else:
            # Check the button.
            if iname is None:
                # No name.
                try:
                    i['name'] = i['value']
                except KeyError:
                    # No value.
                    i['name'] = 'OK'
            try:
                forget = i['value']
            except KeyError:
                i['value'] = i['name']
    # Main loop.
    while True:
        wrap_erase()
        # Print.
        foobar = 0      # I cannot figure out a good name for this one.
        for y in range(len(arg)):
            # y is both the Y coordinate and the index for arg.
            yname, ytype = arg[y]["name"], arg[y]["type"]
            if ytype == "space":
                pass
            elif ytype == "text":
                center_text(y, arg[y]["value"])
            else:
                assert ytype in ("edit_line", "edit_num", "button")
                if ytype == "edit_line":
                    center_text(y, ret_arg[yname])
                if ytype == "edit_num":
                    center_text(y, str(ret_arg[yname]))
                if ytype == "button":
                    center_text(y, arg[y]["value"])
                    if foobar == where:
                        wrap_addstr(y, 0, "**")
                        wrap_addstr(y, xsize - 2, "**")
                foobar += 1
        wrap_refresh()
        # Input.
        foobar = 0
        for y in range(len(arg)):
            yname, ytype = arg[y]["name"], arg[y]["type"]
            if foobar == where:
                direction = None
                if ytype == "edit_line":
                    direction, ret_arg[yname] = edit_line(y, ret_arg[yname])
                if ytype == "edit_num":
                    min_num, max_num = arg[y]["min"], arg[y]["max"]
                    step = arg[y]["step"]
                    direction, ret_arg[yname] = edit_num(y, ret_arg[yname],
                                                    min_num, max_num, step)
                if ytype == "button":
                    ch = wrap_getch()
                    if ch == curses.KEY_UP:
                        direction = "up"
                    elif ch in (curses.KEY_DOWN, ord("\t")):
                        direction = "down"
                    elif ch == 27:
                        direction = "back"
                    elif ch in (ord(" "), ord("\n")):
                        ret_arg["button"] = yname
                        return ret_arg
                    elif ch == curses.KEY_PPAGE:
                        where = 0
                        break # Back to main loop.
                    elif ch == curses.KEY_NPAGE:
                        where = wrap - 1
                        break # Back to main loop.
                # Check what value direction has.
                assert direction in ("up", "down", "back", None)
                if direction == "back":
                    ret_arg["button"] = "back"
                    return ret_arg
                if direction == "up":
                    where -= 1
                    break   # Back to main loop.
                if direction == "down":
                    where += 1
                    break   # Back to main loop.
            if ytype in ("button", "edit_num", "edit_line"):
                foobar += 1
        # Keep where in range.
        where %= wrap

def show_copy_single(s, head=None):
    """show_copy_single(s)
    Show a string and let the user copy it to clipboard.
    NOTE: If there is one or more newlines in the string then
    show_copy_single() will believe that all lines will fit on the
    screen!
    """
    def local_ch_handler(ch):
        if ch in (ord("c"), ord("C")) and have_clipboard:
            copy(s)
    
    if '\n' not in s:
        # Wrap into lines.
        L, i, n = [], 0, len(s)
        line_length = xsize - 4
        if line_length > 50:
            line_length = 50
        # Enough for end-of-line markers, but not too unreadably long lines.
        while i < n:
            tmp = s[i:]
            if len(tmp) > line_length:
                L.append(tmp[:line_length])
            else:
                L.append(tmp)
            i += line_length
        #L.append('')
        s2 = '####\n'.join(L)
        del L
        del tmp
    wrap_erase()
    if have_clipboard:
        center_text(ysize - 2, "Press 'C' to copy.")
    center_text(ysize - 1, "Press space, enter or escape to continue...")
    if head is not None:
        center_text(0, head)
        roll_text(1, ysize - 3, s2, extra_input_handler=local_ch_handler)
    else:
        roll_text(0, ysize - 2, s2, extra_input_handler=local_ch_handler)
    # roll_text() calls wrap_refresh().

def list_choice_to_vdictui(choice_arg, x, data):
    """list_choice_to_vdictui(choice_arg, x, data)
    
    The code of `passwd_tab` and `honeypot_tab`.
    `choice_arg` is the argument to give to `choice`.
    `x` is the alias for the list_choice-button. See `hdictui`.
    `data` is a list of dicts.
    
    
    Keys in the dicts in data
    =========================
    
        - 'id'          Required.  Do thing if the value of this is the
                        same as `x`.
        - 'opt'         Optional. Tuple of two strings or a string
                        (recommended).
                        Possible strings:
                        -----------------
                            
                            - 'choice'          Call `choice` and set
                                                the variable `selection`
                                                to the return value.
                            - 'progress-bar'    Progress-bar.  Create
                                                the object `pb`.
        - 'pre-ui-code'         Optional.  Code to be executed before
                                vdictui().
        - 'post-ui-code'        Optional.  Code to be executed after
                                vdictui().
        - 'ui'                  Optional.  String.  The argument to be
                                given to `vdictui`.
                                `list_choice_to_vdictui` uses `compile`
                                and `str.format`.  Any variable created
                                by 'pre-ui-code' can be used.
                                Set this to normal data for `vdictui`,
                                wrapped in triple-quotes.
    
    Non-global variables available for pre-ui-code and post-ui-code
    ---------------------------------------------------------------
    
        - variables             Empty dict. Always available.
        - selection             If 'choice' in 'opt'-key. Index for
                                `p` or `h`.  Return value of choice().
        - pb                    'post-ui-code' only. If 'progress-bar'
                                in 'opt'-key.
        - result                'post-ui-code' only. If 'ui'-key.
                                Return value of vdictui().
    """
    for foobar in data:
        if foobar['id'] == x:
            # Choose?
            selection = None
            try:
                if 'choice' in foobar['opt']:
                    selection = choice(choice_arg)
                    if isinstance(selection, bool):
                        assert selection == False
                        return      # Will never return True.
            except KeyError:
                selection = None
            
            variables = {}
            
            # Code to run before ui.
            try:
                exec(compile(foobar['pre-ui-code'], '<string-preui>', 'exec'))
            except KeyError:
                pass
            
            while True:
                
                #ui
                try:
                    uidata = foobar['ui']
                    # Stanza-like vs. dicts
                    
                    # WARNING: using [locals(), globals()] makes
                    # api.parse_text choke on something.
                    if len(uidata.split('%')) > len(uidata.split('{')):
                        result = vdictui(api.parse_text(uidata, {
                            'variables': variables,
                            'selection': selection,
                            'p': p,
                            'h': h
                            }))
                    else:
                        result = eval('vdictui({0})'.format(uidata))
                    
                    if result['button'] == 'back':
                        return
                except KeyError:
                    pass
                
                # Progress-bar?
                try:
                    if 'progress-bar' in foobar['opt']:
                        pb = rli_progressbar()
                except KeyError:
                    pass
                
                # Code to run after ui.
                try:
                    exec(compile(foobar['post-ui-code'], '<string-postui>',
                                                                    'exec'))
                except KeyError:
                    pass
                except retry_error:
                    continue
                
                # Done!
                return
    else:
        assert False, "This is impossible!"

def passwd_tab(x):
    """passwd_tab(x)
    x (integer) is the action to be performed on a password.
    See also choice.__doc__ and after_update.__doc__.
    """
    
    list_choice_to_vdictui(False, x, api.parse_text(r"""
# The variables in 'ui' are not available immediately.
# selection is available if opt is choice or both.
# variables is available if pre-ui-code.

# Raising retry_error will make list_choice_to_vdictui redo ui and
# post-ui-code.
    id:                 1
    opt:                ('choice', )
    post-ui-code:       'show_copy_single(p[selection]["value"])'
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 2
    opt:                ('choice', 'progress-bar')
    post-ui-code:       '''
old = p[selection]["value"]
p.update(selection, pb)
new = p[selection]["value"]
after_update(old, new)
'''
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 3
    opt:                ('choice', 'progress-bar')
    pre-ui-code:        '''
if p[selection]["meta"]["type"] in ("10", "64"):
    variables['minlen'] = int(p[selection]["meta"]["minlength"])
    variables['maxlen'] = int(p[selection]["meta"]["maxlength"])
else:
    assert p[selection]["meta"]["type"] == "human"
    variables['minlen'] = variables['maxlen'] = 8
'''

    ui:                 '''
        type:           'text'
        value:          'Minimal required length'
        %
        type:           'edit_num'
        name:           'min'
        value:          variables['minlen']
        min:            1
        %
        %
        type:           'text'
        value:          'Maximal allowed length'
        %
        type:           'edit_num'
        name:           'max'
        value:          variables['maxlen']
        min:            1
        %
        %
        type:           'text'
        value:          "Big & small letters, digits, '!', '_'"
        %
        type:           'button'
        name:           '64'
        value:          'OK'
        %
        %
        type:           'text'
        value:          'Digits only'
        %
        type:           'button'
        name:           '10'
        value:          'OK'
        %'''
    post-ui-code:       R'''
old = p[selection]["value"]
if result['min'] > result['max']:
    pebkac("Is {0} really greater than {1}?\n".format(
                                        result['max'], result['min'])
            + "Look carefully next time.")
    raise retry_error
p.update_meta(selection, result["button"], result["min"], result["max"], pb)
new = p[selection]["value"]
after_update(old, new)
'''
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 4
    ui:                 '''
        type:           'text'
        value:          'What is the password for?'
        %
        type:           'edit_line'
        name:           'name'
        %
        %
        type:           'text'
        value:          'What is the password?'
        %
        type:           'edit_line'
        name:           'value'
        %
        %
        type:           'button'
        %'''
    post-ui-code:       'p.add_nometa(result["name"], result["value"])'
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 5
    opt:                ('progress-bar', )
    ui:                 '''
        type:           'text'
        value:          'What is the password for?'
        %
        type:           'edit_line'
        name:           'name'
        %
        %
        type:           'text'
        value:          'Minimal required length'
        %
        type:           'edit_num'
        name:           'min'
        value:          8
        min:            1
        %
        %
        type:           'text'
        value:          'Maximal allowed length'
        %
        type:           'edit_num'
        name:           'max'
        value:          8
        min:            1
        %
        %
        type:           'text'
        value:          "Big & small letters, digits, '!', '_'"
        %
        type:           'button'
        name:           '64'
        value:          'OK'
        %
        %
        type:           'text'
        value:          'Digits only'
        %
        type:           'button'
        name:           '10'
        value:          'OK'
        %'''
    post-ui-code:       R'''
if result['min'] > result['max']:
    pebkac("Is {0} really greater than {1}?\n".format(
                                        result['max'], result['min'])
            + "Look carefully next time.")
    raise retry_error
p.add(result["name"], None, result["button"], result["min"],
                                                        result["max"], pb)
'''
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 6
    opt:                ('choice', )
    post-ui-code:       'p.remove(selection)'
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
"""))

def honeypot_tab(x):
    """honeypot_tab(x)
    x (integer) is the action to be performed on a honeypot.
    See also choice.__doc__"""
    list_choice_to_vdictui(True, x, api.parse_text(r"""
    id:                 1
    opt:                ('progress-bar', )
    post-ui-code:       'show_copy_single(h.pick(pb=pb))'
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 2
    opt:                ('progress-bar', )
    ui:                 '''
        type:           'text'
        value:          'How many?'
        %
        type:           'edit_num'
        name:           'num'
        min:            1
        max:            len(h)
        %
        %
        type:           'text'
        value:          'Separate them with?'
        %
        type:           'edit_line'
        name:           'sep'
        value:          ','
        %
        %
        type:           'button'
        %'''
    post-ui-code:       '''
s = h.pick(result["num"], result["sep"], pb=pb)
show_copy_single(s)
'''
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 3
    opt:                ('progress-bar', )
    ui:                 '''
        type:           'text'
        value:          'How many?'
        %
        type:           'edit_num'
        name:           'num'
        min:            1
        max:            len(h)
        %
        %
        type:           'button'
        %'''
    post-ui-code:       '''
result = h.pickl(result["num"], pb=pb)
for s in result:
    show_copy_single(s)
'''
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 4
    ui:                 '''
        type:           'text'
        value:          'What is the fake password?'
        %
        type:           'edit_line'
        name:           'line'
        %
        %
        type:           'button'
        %'''
    post-ui-code:       'h.add(result["line"])'
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    id:                 5
    opt:                ('choice', )
    post-ui-code:       'h.remove(selection)'
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
"""))

def copy(x):
    """copy(s)
    copy s to the clipboard.
    Not written by me."""
    # "primary":
    xsel_proc = subprocess.Popen(['xsel', '-pi'], stdin=subprocess.PIPE)
    xsel_proc.communicate(api.b(x))
    # "clipboard":
    xsel_proc = subprocess.Popen(['xsel', '-bi'], stdin=subprocess.PIPE)
    xsel_proc.communicate(api.b(x))

def set_tab(direction):
    """set_tab(direction)
    Move to another tab in main().
    0 <= direction <= 3 or direction in ("<", ">")"""
    global tabnum
    assert api.is_anystr(direction)
    if direction == ">":
        tabnum += 1
    elif direction == "<":
        tabnum -= 1
    elif direction == "first":
        tabnum = 0
    elif direction == "last":
        tabnum = num_tabs - 1
    else:
        raise api.err_idiot("What the fuck does that mean?")
    if tabnum < 0:
        tabnum = num_tabs - 1
    if tabnum >= num_tabs:
        tabnum = 0

def choice(honeypot):
    """choice(honeypot)
    Return index for p if honeypot == False.
    Return index for h if honeypot == True.
    Returns False if the user cancels."""
    wrap_erase()
    thelist = []
    if honeypot:
        center_text(0, "Please select fake-password.")
        for x in h:
            thelist.append(x)
    else:
        center_text(0, "Please select password.")
        for x in p:
            thelist.append(x["name"])
    if len(thelist) > 0:
        #I know this will ask the user even if there only is one choice, but
        #it will show which password/honeypot the only one is.
        return list_choice(1, ysize - 1, thelist)
    else:
        return False

def zxcv_handler(x):
    """zxcv_handler(x)
    x is whatever wrap_getch() has returned.
    Handle undo/redo/make backup/clear clipboard."""
    if x in (ord("z"), ord("Z"), ord("b"), ord("B")):
        api.undo(p, h)
    if x in (ord("x"), ord("X"), ord("n"), ord("N")):
        api.redo(p, h)
    if have_clipboard and x in (ord("v"), ord("V"), ord(",")):
        copy("EMPTY")
    if x in (ord("c"), ord("C"), ord("m"), ord("M")):
        # Make backup.
        result = vdictui([
            {
                'type': 'text',
                'value': 'File name (.tar.gz)'
            }, {
                'type': 'edit_line',
                'name': 'tarball_name'
            }, {}, {
                'type': 'button'
            }])
        if result["button"] == "back":
            return
        tarball_name = result['tarball_name']
        try:    # Normal suffix?
            test = tarball_name[-4:] == ".tgz"
            if not test:
                test = tarball_name[-7:] == ".tar.gz"
        except:
            test = False
        if not test:
            wrap_erase()
            center_text(0, "Append suffix (Y/N)?")
            wrap_refresh()
            while True:
                ch = wrap_getch()
                if ch in (ord("y"), ord("Y")):
                    tarball_name += ".tar.gz"
                    break
                if ch in (ord("n"), ord("N")):
                    break
        # Tarballize.
        old_dir = os.getcwd()
        os.chdir(os.path.expanduser("~"))
        tarball = tarfile.open(os.path.expanduser(tarball_name), "w:gz")
        tarball.add(".skogpasswdman")
        tarball.close()
        os.chdir(old_dir)

def list_choice(ypos, yspace, thelist, ct=False):
    """list_choice(ypos, yspace, thelist, ct=False)
    thelist is a list of strings (buttons).
    It can change tabs if ct == True.
    Returns True if the user changed tab.
    Returns False if the user canceled.
    Returns an index to thelist if the user has `clicked` on one of the
    buttons.
    ypos is the Y-coordinate.
    yspace is the number of rows list_choice() will eat of the screen.
    See also zxcv_handler.__doc__"""
    assert len(thelist) > 0
    xspace = 0
    for x in thelist:
        if len(x) > xspace:
            xspace = len(x)
    xspace += 4         # [**]
    assert yspace >= 7 and xspace <= xsize
    center_text(ypos, "Page-up up w k 8")
    center_text(ypos + 1, "Choose with space, tab or enter")
    center_text(ypos + 2, "or escape to cancel.")
    center_text(ypos + yspace - 1, "Page-down down s j 2")
    # The size of a ``page``.
    page = yspace - 6
    # Leftover columns on the right.
    x_leftover = xsize - xspace
    if x_leftover >= 8: # Enough room for "<-Choose"?
        show_arrow = True
    else:
        show_arrow = False
    # The currently selected button.
    choice = 0
    size = len(thelist)
    while True:
        # Draw.
        for i in range(page):
            # Offset of the current page in the list.
            offset = choice - choice%page
            button_listpos = offset + i
            button_ypos = i + ypos + 4
            # Surrounding brackets.
            wrap_addch(button_ypos, 0, ord("["))
            wrap_addch(button_ypos, xspace - 1, ord("]"))
            # Past end?
            if button_listpos >= size:
                # Put empty.
                wrap_hline(button_ypos, 0, ord("#"), xspace)
                wrap_hline(button_ypos, xspace, ord(" "), x_leftover)
            else:
                # Put line.
                if choice % page == i:  #Selected?
                    wrap_addch(button_ypos, 1, ord("*"))
                    wrap_addch(button_ypos, xspace - 2, ord("*"))
                    if show_arrow:
                        wrap_addstr(button_ypos, xspace, "<-Choose")
                else:
                    if show_arrow:
                        wrap_hline(button_ypos, xspace, 32, x_leftover)
                    wrap_addch(button_ypos, 1, ord(" "))
                    wrap_addch(button_ypos, xspace - 2, ord(" "))
                #Print the characters.
                for x in range(2, xspace - 2):
                    # Print the buttons.
                    if x - 2 >= len(thelist[button_listpos]):
                        wrap_addch(button_ypos, x, ord(" "))
                    else:
                        wrap_addstr(button_ypos, x,
                                            thelist[button_listpos][x - 2])
        # Print the 'rollability-indicators'.
        if offset - page < 0:
            wrap_hline(ypos + 3, 0, ord("-"), xspace)
        else:
            wrap_hline(ypos + 3, 0, ord("^"), xspace)
        if offset + page > len(thelist) - 1:
            wrap_hline(ypos + yspace - 2, 0, ord("-"), xspace)
        else:
            wrap_hline(ypos + yspace - 2, 0, ord("v"), xspace)
        wrap_refresh()
        # Handle input.
        ch = wrap_getch()
        if ch == 27:
            return False
        choice += common_updown_handler(ch, page)
        # Don't let choice be out of range
        if choice < 0:
            choice = 0
        if choice >= len(thelist):
            choice = len(thelist) - 1
        # Choose.
        if ch in (ord("\t"), ord(" "), ord("\n")):
            return choice
        zxcv_handler(ch)
        if common_ct_handler(ch) and ct:
            return True

def roll_text(ypos, yspace, thetext, ct=False, extra_input_handler=None):
    """roll_text(ypos, yspace, thetext, ct=False, extra_input_handler=None)
    Show a large amount of text on the screen.
    It can change tabs if ct == True.
    Returns True if the user changed tab.
    Returns False if the user canceled.
    ypos is the Y-coordinate.
    yspace is the number of rows roll_text() will eat of the screen.
    `extra_input_handler` is a function that takes 1 argument; integer
    returned by wrap_getch().
    See also zxcv_handler.__doc__"""
    thelines = thetext.split("\n")
    page = yspace - 4
    linepos = 0
    center_text(ypos, "Page-up up w k 8")
    center_text(ypos + yspace - 1, "Page-down down s j 2")
    while True:
        #Print.
        for i in range(page):
            for x in range(xsize):
                try:
                    uc = thelines[i + linepos][x]
                except:
                    uc = ' '
                wrap_addstr(i + ypos + 2, x, uc)
        if linepos < 1:
            wrap_hline(ypos + 1, 0, ord("-"), xsize)
        else:
            wrap_hline(ypos + 1, 0, ord("^"), xsize)
        if linepos + page > len(thelines):
            wrap_hline(ypos + yspace - 2, 0, ord("-"), xsize)
        else:
            wrap_hline(ypos + yspace - 2, 0, ord("v"), xsize)
        wrap_refresh()
        ch = wrap_getch()
        if common_ct_handler(ch) and ct:
            return True
        if ch in (27, ord('\n'), ord(' ')):
            return False
        # Roll.
        oldpos = linepos
        linepos += common_updown_handler(ch, page)
        if extra_input_handler is not None:
            extra_input_handler(ch)
        if linepos < 0 or linepos >= len(thelines):
            linepos = oldpos

def hdictui(arg):
    """hdictui(arg)
    `arg` is a list of dicts.
    
    Required keys
    -------------
    
        - 'name'        Name of the tab.
        - 'type'        'list_choice' or 'roll_text'.
    
    
    More required keys when 'type': 'list_choice'
    ---------------------------------------------
    
        - 'choices'     list of strings; button labels.
        - 'aliases'     A list that will be indexed by the integer
                        return value of `list_choice`.
        - 'function'    Function to be called, its first argument will
                        be *the* value in 'aliases'.
     
     
     More required keys when 'type': 'roll_text'
     -------------------------------------------
     
        - 'text'        Obvious.
    
    """
    global tabnum
    global num_tabs
    tabnum = num_tabs = 0
    tab_names = [[], []]
    for i in arg:
        num_tabs += 1
        tab_names[0].append(i['name'].lower())
        tab_names[1].append(i['name'].upper())
    while True:
        # Tab headers.
        wrap_erase()
        if xsize >= 80:
            s = "Home left a h 4"
            wrap_addstr(0, 0, s)
            wrap_addstr(0, len(s), "::")
            x_pos = len(s) + 2
            for i in range(num_tabs):
                if i == tabnum:
                    wrap_addstr(0, x_pos, tab_names[1][i])
                else:
                    wrap_addstr(0, x_pos, tab_names[0][i])
                x_pos += len(tab_names[0][i])
                wrap_addstr(0, x_pos, ":")
                x_pos += 1
            wrap_addstr(0, x_pos, ":6 l d right end")
            # zxcv
            if have_clipboard:
                wrap_addstr(ysize - 2, 0, "(z/b) undo : (x/n) redo : (c/m)" +
                    " Make backup : (v/,) Clear clipboard : (^C) quit")
            else:
                wrap_addstr(ysize - 2, 0, "(z/b) undo : (x/n) redo : (c/m)" +
                    " Make backup : (^C) quit")
            # Lines.
            wrap_hline(1, 0, ord("="), xsize)
            wrap_hline(ysize - 3, 0, ord("="), xsize)
            wrap_refresh()
        else:
            pass    #TODO
        # Tab content.
        the_dict = arg[tabnum]
        the_type = the_dict['type']
        if the_type == 'list_choice':
            result = list_choice(2, ysize - 5, the_dict['choices'], True)
            if not isinstance(result, bool):
                # Call custom function with an alias for the result.
                the_dict['function'](the_dict['aliases'][result])
        elif the_type == 'roll_text':
            roll_text(2, ysize - 5, the_dict['text'], True, zxcv_handler)
        else:
            assert False, "Odd type '{0}' in {1}".format(the_type, the_dict)

def main():
    """See list_choice.__doc__, passwd_tab.__doc__, honeypot_tab.__doc__,
    roll_text.__doc__ and die.__doc__."""
    help_text = """
Uppercase W/K, A/H, S/J, D/L will be treated as Page up, Home, Page down, end.

The "change meta-data & update"-button in the "Passwords"-tab:
    1.  If the password was created with the "Add existing"-button: use the
        "change meta-data & update"-button.
    2.  If the password was created with the "Create new"-button: use the
        "update"-button.
    3.  If the minimal required length for the password or the maximal allowed
        length or the allowable characters have changed: use the
        "change meta-data & update"-button.
    
Difference between "Add existing" and "Create new":
    Click on those buttons and see what happens. They are not dangerous.

The "Undo"- and "Redo"-buttons undoes/redoes the LATEST change in the password
tab or the fake-password tab, independent of which tab you're currently in.

The fake-passwords/honey pots are intended to be used as traps to catch
crackers. The "pick"-buttons picks a random fake-password, independent of what
you have selected. You should add fake-passwords such as "password" and
"drowssap".
"""
    about_text = """
skogpasswdman is a program for remembering and updating passwords. It also
remembers honey-pots (fake-passwords to catch crackers). It has infinite
undo/redo.
 
It can remember old human-generated passwords, create new passwords (digits
or big letters, small letters, digits, underscores and exclamation marks)
with randomized length, update passwords and obviously show and remove
passwords. It can add, remove honey-pots and randomly choose (pick)
honey-pots in two different flavors.
 
It stores the passwords and honey-pots in XML files, so they can be read with
a normal text-editor (normal for unix), depending on the user. The XML files
are not encrypted, so that you don't need to remember an extra password.
  If you want encryption you should encrypt your home-directory.
"""
    passwd_choices = ["Show/copy password",
                      "Update",
                      "Change meta-data & update",
                      "Add existing",
                      "Create new",
                      "Remove"]
    honeypot_choices = ["Pick",
                        "Bad pick many",
                        "Good pick many",
                        "Add",
                        "Remove"]
    # Use numbers in order to not break passwd_tab and honeypot_tab.
    passwd_aliases = [1, 2, 3, 4, 5, 6]
    honeypot_aliases = [1, 2, 3, 4, 5]
    hdictui([
        {
            'name': 'Passwords',
            'type': 'list_choice',
            'choices': passwd_choices,
            'aliases': passwd_aliases,
            'function': passwd_tab
        }, {
            'name': 'Fake passwords',
            'type': 'list_choice',
            'choices': honeypot_choices,
            'aliases': honeypot_aliases,
            'function': honeypot_tab
        }, {
            'name': 'Help',
            'type': 'roll_text',
            'text': help_text
        }, {
            'name': 'About',
            'type': 'roll_text',
            'text': copywrong + about_text
        }])

DEBUG = False
tabnum = 0
have_clipboard = __HAVE_CLIPBOARD__

if DEBUG:
    # 80x20.
    u = ord(' ')
    tmp = debug_curses_screen = []
    for x in range(80):
        tmp.append({'key': u})
    for y in range(20):
        debug_curses_screen.append(tmp)
    debug_curses_cursor = None, None
    v, f, f, f, f = sys.version_info
    if v == 2:
        uchr = unichr
    else:
        uchr = chr

if have_clipboard:
    import subprocess

if __name__ == "__main__":
    h = api.honeypot()
    p = api.passwd()
    locale.setlocale(locale.LC_ALL, '')
    code = locale.getpreferredencoding()
    if DEBUG:
        # 22 rows gives space for cursor coordinates and pdb prompt.
        xsize, ysize = 80, 20
    else:
        tty = curses.initscr()
        curses.noecho()
        curses.cbreak()
        curses.meta(1)
        tty.keypad(1)
        ysize, xsize = tty.getmaxyx()
        if xsize < 80:
            if xsize < 40 or ysize < 18:
                curses.endwin()
                print("Need at least 40x18 or 80x12 COLSxROWS")
        elif ysize < 12:
            curses.endwin()
            print("Need at least 40x18 or 80x12 COLSxROWS")
    try:
        main()
    except KeyboardInterrupt: #^C
        die()
    except:
        if not DEBUG:
            tty.keypad(0)
            curses.echo()
            curses.nocbreak()
            curses.endwin()
        print("AAARGH!   I'M DYING A PAINFUL DEATH!   AAARGH!")
        try:
            raise
        except UnicodeEncodeError as x:
            try:
                bad = unicodedata.name(x.object[x.start:x.end])
            except ValueError:
                bad = 'CHARACTER THAT DOES NOT EXIST'
            print('I broke my fingers attempting to write a {0}'.format(bad))
            print('Use a better encoding.')
            traceback.print_exc()
            sys.exit(1)
        except UnicodeDecodeError as x:
            print('I broke my eyes attempting to read a {0}'.format(
                                        x.object[x.start:x.end].__repr__()))
            print('Use a better encoding.')
            traceback.print_exc()
            sys.exit(1)
        except:
            raise