#!/usr/bin/python
# -*- encoding: utf-8 -*-

copywrong = (
"""#Copyright (c) 2013, 2014, Oskar Skog <oskar.skog.finland@gmail.com>
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met:
#
#1.  Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#2.  Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#POSSIBILITY OF SUCH DAMAGE.
""")

import passwdmanapi as api
import sys
import logging
import time
import os
import os.path
import getopt
import shutil

__doc__ = """The functions show_help(), passwd_help(), honeypot_help(),
bells_and_whistles() and bugs() takes no arguments and prints their
__doc__-string to standard output.
See passwdmancli(1) to understand the interface.
Some global stuff:
    import passwdmanapi as api
    p, h = api.passwd(), api.honeypot()
    verbose             verbose mode (command)
    interactive         interactive mode (command line flag)
    main()
    se()                complain about syntax errors
    err(x)              sow("!" + x + "\\n")
    sow(x)              print x to stdout
    siw()               read line from stdin
    theline             set by main() and used by se(), the line that might
                            cause a syntax error
    passwd_cmds()
    honeypot_cmds()
 """

def se():
    """se() - syntax error
    Show error message containing theline.
    """
    sow("!syntax error, type 'help'\n")
    sow('!')
    sow(theline)        #str.format() doesn't like Unicode.
    sow("\n")
    if not interactive:
        sys.exit(1)

def err(x):
    """err(x) - error messages
    "!{}\n".format(x)
    Program dies if not in interactive mode.
    """
    sow("!")
    sow(x)
    sow("\n")
    if not interactive:
        sys.exit(1)

def sow(x):             #Do the Unicode-stuff here.
    """sow(x) - Write to stdout. It encodes the string as UTF-8."""
    sys.stdout.write(api.b2u3(x))         #It is used a lot.

def siw():
    """siw() - Read from infile. It decodes the UTF-8 input."""
    global infile
    return api.u(infile.readline())

def v(x):       #Verbose.
    """def v(x):
    global verbose
    if verbose:
        sow("#" + x + "\n")
"""
    if verbose:
        sow("#" + x + "\n")     #Make the output comments

def show_help():
    """#HELP MESSAGE
#passwdmancli uses  colon separated fields  as input. Everything inside angle
#brackets < >,  is intended to be expanded in your brain.
#It tries to be more grepable by making the first letter in error messages be
#an exclamation  mark and  the first  letter in human-friendly  messages be a
#hash/number sign.  Multi-line  outputs are  terminated by a "#READY"
#message. Unless otherwise noted, quotes  around angle  brackets are optional
#and may be either single quotes or double quotes. If the first letter in its
#input is a '#', it will ignore the line. If the first letter in it input is
# '|', it prints out the rest of the line
#It allows ANY crap to surround the commands in the fields.
#It's outputs are prepended with `<command> | tr : .` + '?'
#The error messages are hopefully obvious enough.
#passwd:help            Show help for passwd:*
#honeypot:help          Show help for honeypot:*
#verbose:on            Verbose output, the command 'hell' does the same thing.
#verbose:off            Brief output.
#undo                   Undo last change to passwd or honeypot, there is also
#help                   Obvious.                                'redo'.
#exit                   Obvious.
#bugs                   Bugs.
#whistles               Bells and whistles.
"""
    sow(show_help.__doc__)
def passwd_help():      #22 lines + ('#READY') + new line for input
    """#HELP MESSAGE
#Do you remember the angle brackets and the quotes? If not: type 'help'
#passwd:add:<type>:<min>:<max>:"<name>"         Add password, for <name> with
#                       a minimal length of <min> and maximal length of <max>
#                       <type> == 10 = use digits only, <type> == 64 = use
#                       big and small letters, digits, '!' and '_'.
#passwd:add_human:"<name>"                      Add human generated password
#                       for <name>. The password is entered on a new line.
#passwd:remove:<index>                          Remove, by index.
#passwd:remove:"<name>"                         Remove, by name.
#passwd:get:<index>     passwd:get:"<name>"     Get password.
#passwd:meta:<index>                            Get meta-data, which is...
#passwd:meta:"<name>"                           ...useful when updating.
#passwd:remove:<index>          passwd:remove:"<name>"       remove password
#passwd:list                              list all passwords (index and name)
#passwd:update:"<name>"         passwd:update:<index>   update password, will
#                       print out the new and the old.
#passwd:update_meta:<type>:<min>:<max>:"<name>"      Update the password,...
#passwd:update_meta:<type>:<min>:<max>:<index>       ...but use new meta-data
#                                       (the <type>, <min> and <max>)
#               passwd:update      reuses the existing meta-data
#
"""
    sow(passwd_help.__doc__)

def honeypot_help():
    """#HELP MESSAGE
#Do you remember the angle brackets and the quotes? If not: type 'help'
#The honey pots are human generated  passwords, whose only purposes are to be
#used as traps.
#honeypot:add:"<value>"                 Add a new honey pot.
#honeypot:pick                          Pick a random honeypot.
#honeypot:pick:<n>:"<sep>"              Pick <n> random honeypots use <sep>
#                                       as a separator between them.
#honeypot:pickl:<n>                     "honeypot.pickl?'one','two','three'"
#                                       "\'" is an escape for "'".
#honeypot:remove:"<value>"              Remove.
#honeypot:list                          List.
#
#
#
#
#
#
#
#
#
#
"""
    sow(honeypot_help.__doc__)
   
def bells_and_whistles():
    """#BELLS AND WHISTLES
#       *       Comments:       It ignores input-lines that begins with a '#'
#
#       *       Pipe-through:   If it's input begins with a '|', the rest of
#               the line is written to stdout.
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
#
"""
    sow(bells_and_whistles.__doc__)

def bugs():
    """#BUGS
#If verbose mode is enabled, it will shout '#READY' to stdout way too much.
#
#
#
#It is noisy and babbles to much.
#It uses the following methods to parse it's input:
#       int()           python built-in
#       'if "keyword" in some_variable:'
#Some of these big message screens looks ugly.
#Bad speling in the error messages.
#
#
#
#
#
#
#
#
#
#
#
"""
    sow(bugs.__doc__)
    
def passwd_update(x):
    """passwd_update(x) - update the password x using its own meta-data.
    x is either the name or the index.
    passwd:update:<x>"""
    try:                        #unquote gets rid of optional quotes.
        index = p.mkindex(api.unquote(x))  #mkindex greps it's argument...
    except:                             #...in the list and returns an index.
        err("not found")
        return
    old = p[index]["value"]       #It must show the old password, because...
                              #...it is probably required to change password.
    v("This may take a while.")       #Verbose.
    try:
        p.update(index)              #Do lots of the work in the right place.
    except api.err_nometa:
        err("no meta")               #It requires the meta-data.
        return
    new = p[index]["value"]
    sow("#old:new\n")
    sow("passwd.update?'{0}':'{1}'\n".format(old, new)) #Always 64 or 10.
    return
    
def passwd_update_meta(x):
    """passwd_update_meta(x) - Update the password x with new meta-data.
    Variant of passwd_update().
    passwd:update_meta:<type>:<min>:<max>:<name_or_index>"""
    fields = x.split(':', 3)
    if len(fields) < 4: #It takes 4 arguments.
        se() #Syntax error.
        return
    name = api.unquote(fields[3])
    try:
        index = p.mkindex(name)     #Where is it?
    except:
        err("not found")
        return
    old = p[index]["value"]             #Remember old.
    v("This may take a while.")
    try:
        p.update_meta(index, fields[0], fields[1], fields[2])
    except api.err_idiot:       #Incorrect usage.
        err("stupid arguments")
        return
    new = p[index]["value"]
    sow("#old:new\n")
    sow("passwd.update?'")
    sow(old)
    sow("':'{0}'\n".format(new))
    return
    
def passwd_add(x):
    """passwd_add(x) - generate and add a new password.
    Name xor index.
    passwd:add:<type>:<min>:<max>:<name>"""
    #
    add_args = x.split(':', 3)
    if len(add_args) < 4:
        se()
        return
    add_type = add_args[0]   #"64" or "10".
    try:
        add_min = int(add_args[1])
        add_max = int(add_args[2])
    except:
        se()
        return
    add_name = api.unquote(add_args[3])
    try:
        int(add_name)          #Check if it will be treated as an integer.
        sow("#WARNING: ITS NAME WILL BE BELIEVED TO BE AN INDEX!\n")
        sow("#IF YOU REMOVE IT BY ITS NAME, BAD THINGS CAN HAPPEN!\n")
    except:
        pass
    #Start testing add_type.
    if "human" in add_type:
        if not interactive:
            sow("!Use 'passwd:add_human'.\n")
        se()
        sow("#Use 'passwd:add_human'.\n") #add_human is inside passwd_cmds().
        return
    elif "10" in add_type:
        try:            #Use digits only.
            p.add(add_name, api.get10(api.getint(add_min, add_max + 1)), 
                  "10", str(add_min), str(add_max))
        except api.err_duplicate:
            err("duplicate")
            return
        v("Added base10 password.")
        return
    elif "64" in add_type:      #WARNING: Copy-pasted from 'elif "10"...'
        #                        and hand-hacked '10'->'64'.
        try:    #A-Z a-z '_' '!'
            p.add(add_name, api.get64(api.getint(add_min, add_max + 1)), 
                  "64", str(add_min), str(add_max))
        except api.err_duplicate:
            err("duplicate")
            return
        v("Added base64 password.")
        return
    else:
        se()
        return

def passwd_cmds(x):
    """passwd_cmds(x) - handle all "passwd:*".
    x is the line with ^'passwd:' and newline$ removed.
    passwd_update()
    passwd_update_meta()
    passwd_add()"""
    twofields = x.split(':', 1)
    a = twofields[0]
    if len(twofields) < 2:
        if "list" in a:         #list doesn't take any arguments.
            index = 0
            sow("#\t\tindex:\tname\n")   #Human readable message.
            for l in p:
                sow("passwd.list?\t{0}:\t'".format(index))
                sow(l["name"])
                sow("'\n")
                index += 1
            sow("#READY\n")
            return
        elif "help" in a:       #All big messages are done by calling a...
            passwd_help()       #...function that prints out it's doc-string.
            return
        else:
            se()
            return
    else: #passwd:<a>:<b>
        b = twofields[1]
        if "add_human" in a:            #WARNING: Must be before "add".
            s = siw()
            name = api.unquote(b)
            try:
                int(name)          #Check if it will be treated as an integer.
                sow("#WARNING: ITS NAME WILL BE BELIEVED TO BE AN INDEX!\n")
                sow("#IF YOU REMOVE IT BY ITS NAME, BAD THINGS CAN HAPPEN!\n")
            except:
                pass
            try:
                p.add_nometa(name, s[:-1])
            except api.err_duplicate:
                err("duplicate")
                return
            v("Added human generated password.")
            return
        elif "add" in a:                #WARNING: Must be after "add_human".
            passwd_add(b)       #Go up.
            return
        elif "get" in a:      #Get the value of a password; get the password.
            try:
                the_value = p[p.mkindex(api.unquote(b))]["value"]
            except:
                err("not found")
                return
            sow("passwd.get?'")
            sow(the_value)
            sow("'\n")
            return
        elif "update_meta" in a:        #WARNING: Must be before "update" and
                                        #"meta".
            passwd_update_meta(b)       #Go up.
            return
        elif "update" in a:             #WARNING: Must be after "update_meta".
            passwd_update(b)
            return
        elif "meta" in a:               #WARNING: Must be after "update_meta".
            try:                #Get meta-data for a password.
                metadata = p[p.mkindex(api.unquote(b))]["meta"]
                sow("#\t\ttype:\tminlength:\tmaxlength\n")      #safe
                sow("passwd.meta?\t'{0}':\t'{1}':\t\t'{2}'\n".format(
                                                        metadata["type"],
                                                       metadata["minlength"],
                                                      metadata["maxlength"]))
            except:
                err("no meta")
            return
        elif "remove" in a:
            try:
                p.remove(api.unquote(b))
            except api.err_notfound:
                err("not found")
                return
            return
        else:
            se()
            return

def honeypot_cmds(x):
    """honeypots_cmds(x) - handle all "honeypot:*".
    x is the line with ^'honeypot:' and newline$ removed."""
    twofields = x.split(':', 1)
    a = twofields[0]
    if len(twofields) < 2:
        if "list" in a:
            index = 0
            sow("#\t\tindex:\tname\n")
            for value in h:
                sow("honeypot.list?\t{0}:\t'".format(index))
                sow(value)
                sow("'\n")
                index += 1
            sow("#READY\n")
            return
        elif "help" in a:
            honeypot_help()
            return
        elif "pick" in a:       #Pick a random honeypot.
            #pick takes either 0 or 2 arguments, look down.
            #This pick takes 0.
            v("This may take a while.")
            sow("honeypot.pick?'")
            sow(h.pick())
            sow("'\n")
            return
        else:
            se()
            return
    else:       #honeypot:<a>:<b>
        b = twofields[1]
        if "add" in a:
            name = api.unquote(b)
            try:
                int(name)          #Check if it will be treated as an integer.
                sow("#WARNING: ITS NAME WILL BE BELIEVED TO BE AN INDEX!\n")
                sow("#IF YOU REMOVE IT BY ITS NAME, BAD THINGS CAN HAPPEN!\n")
            except:
                pass
            try:
                h.add(name)
            except api.err_duplicate:
                err("duplicate")
                return
            return
        elif "pickl" in a:      #WARNING: Must be before "pick".
            try:
                n = int(b)
            except:
                err("Argument must be an integer.")
            try:
                the_list = h.pickl(n, False)
            except api.err_idiot:
                err("Argument is too big.")
            sow("honeypot.pickl?")
            tmp_str = ""
            for x in the_list:
                tmp_str += "'"  #Opening quote.
                for y in x:
                    if y == "'":
                        tmp_str += "\\'"        #Escape.
                    else:
                        tmp_str += y
                tmp_str += "'," #Closing quote and comma.
            sow(tmp_str[:-1])   #No trailing comma.
            sow("\n")
            return
        elif "pick" in a:       #WARNING: Must be after "pickl".
            args = b.split(':', 1)
            if len(args) < 2:
                se()
                return
            try:
                n = int(args[0])
            except:
                err("n must be an integer")
                return
            sep = api.unquote(args[1])
            try:                       #3rd arg, make it raise instead of log.
                tmp_str = h.pick(n, sep, False)
            except api.err_idiot:
                err("n is too big")
                return
            sow("honeypot.pick?'")
            sow(tmp_str)
            sow("'\n")
            return
        elif "remove" in a:
            try:
                h.remove(api.unquote(b))
            except api.err_notfound:
                err("not found")
                return
            return
        else:
            se()
            return

def main():             #Finally.
    """main() - main loop."""
    global verbose
    global p
    global h
    global theline
    sow(copywrong)
    while True:
        v("READY")  #Show this message after every command, if verbose.
                    #It should be moved to line 666.
        temporary_variable = siw()
        if len(temporary_variable) < 1: #Not even an empty line.
            quit()
        theline = temporary_variable[:-1]       #Get rid of newline.
        if len(theline) < 1:
            continue
        if theline[0] == "#":           #Comment.
            continue
        if theline[0] == "|":           #Pipe through.
            sow(theline[1:])
            sow("\n")
            continue
        twofields = theline.split(':', 1)
        a = twofields[0]
        if len(twofields) < 2:  #Check some really short ones.
            if "exit" in a:
                quit()
            elif "help" in a:
                show_help()
            elif "undo" in a:
                if interactive:
                    try:
                        api.undo(p, h)
                    except:
                        err("cannot undo")
                        continue
                    v("Undone something.")
                else:
                    err("Not in interactive mode.")
            elif "redo" in a:
                if interactive:
                    try:
                        api.redo(p, h)
                    except:
                        err("cannot redo")
                        continue
                    v("Redone something.")
                else:
                    err("Not in interactive mode.")
            elif "bells" in a or "whistles" in a:
                bells_and_whistles()
                continue
            elif "bugs" in a:
                bugs()
                continue
            elif "hell" in a:           #Synonym for verbose:on
                verbose = True
                sow("#verbose mode enabled\n")
            else:
                se()    #Syntax error.
        else: #Check some longer ones.
            #The string has been split.
            b = twofields[1]
            if "passwd" in a:
                passwd_cmds(b)      #passwd:*
            elif "honeypot" in a:
                honeypot_cmds(b)    #honeypot:*
            elif "verbose" in a:
                if "on" in b:           #666
                    verbose = True
                    sow("#verbose mode enabled\n")
                elif "off" in b:
                    verbose = False
                else:
                    se()
                    continue
            else:
                se()
                continue

#Initialization.
p = api.passwd()
h = api.honeypot()
verbose = False
interactive = False
theline = ""
logging.basicConfig(level=logging.CRITICAL)     #STFU
if __name__ == "__main__":
    try:
        o, a = getopt.getopt(sys.argv[1:], "iB", ["interactive",
            "single-backup"])
    except getopt.GetoptError as err:
        sys.stderr.write("{0}\n".format(err))
        sys.exit(1)
    if len(a) > 0:
        infile = open(a[0], "r")
    else:
        infile = sys.stdin
    for x, y in o:
        if x in ("-i", "--interactive"):
            interactive = True
        if x in ("-B", "--single-backup"):
            del p
            del h
            shutil.copy(os.path.expanduser("~/.passwdman/passwords"),
                os.path.join(os.path.expanduser("~/.passwdman/undoable"),
                "passwords" + '-' + time.ctime()))
            time.sleep(1)
            shutil.copy(os.path.expanduser("~/.passwdman/honeypots"),
                os.path.join(os.path.expanduser("~/.passwdman/undoable"),
                "honeypots" + '-' + time.ctime()))
            p = api.passwd(False)
            h = api.honeypot(False)
    main()