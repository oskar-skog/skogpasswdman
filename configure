#!/bin/sh
#NOTE This file is auto-generated by the python-script "configure.2", which
#is auto-generated by this file.
#Copyright (c) 2013, Oskar Skog <oskar.skog.finland@gmail.com>
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met:
#
#1.  Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
#2.  Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#POSSIBILITY OF SUCH DAMAGE.
verbose_mode=0
for x in $*; do
    if [ $x = "--verbose" ]; then
        verbose_mode=1
        break
    fi
    if [ $x = "-v" ]; then
        verbose_mode=1
        break
    fi
done
verbose()
{
    if [ $verbose_mode -gt 0 ]; then
        echo $*
    fi
}
#Important checks.
verbose Checking for python...
pyck=0          #No python.
for test_dir in `echo $PATH | tr : ' '`; do
    for x in `ls $test_dir | grep ^python`; do
        if [ -x $test_dir/$x ]; then
            pyck=1   #python
            break 2
        fi
    done
done
if [ $pyck -eq 0 ]; then
    echo Python is required.
    exit 1
fi
#Where is python?
for test_dir in `echo $PATH | tr : " "`; do
    for test_file in `ls $test_dir | grep ^python`; do
        if [ -x $test_dir/$testfile ] ; then
            python_exec=$test_dir/$test_file
            break 2
        fi
    done
done
#Create dirsinstall.
verbose Creating dirsinstall...
cat > dirsinstall << __EOF__
#!/bin/sh
#This script will make sure that
#all the specified directories exist.
while [ \$# -gt 0 ]; do
    if [ -d \$1 ]; then
        shift
        continue
    fi
    mkdir \$1
    shift
done
__EOF__
chmod +x dirsinstall
#Create passwdmanapi.xml.fix.
verbose Creating passwdmanapi.xml.fix...
echo "#!${python_exec}" > passwdmanapi.xml.fix
cat >> passwdmanapi.xml.fix << __EOF__
#!/usr/bin/python
import sys
#Fix broken Docbook XML in passwdmanapi.xml.

chunks = []

while True:
    l = sys.stdin.readline()
    if len(l) < 1:
        quit()
    if "<refsynopsisdiv" in l:
        sys.stdout.write(l)
        #Inside the bad place.
        while True:
            l = sys.stdin.readline()
            if "<command>" in l:
                sys.stdout.write("<synopsis>\n#!/usr/bin/python<sbr/>\n")
                continue
            if "import" in l or "passwdmanapi" in l:
                continue
            if "<sbr/>" in l:
                sys.stdout.write("import passwdmanapi<sbr/>\n")
                continue
            if l == "</refsynopsisdiv>\n":
                break           #Do not end synopsis here.
            try:
                chunks.append(l[37:-21])
            except:
                pass    #</synopsis>
        #Write out the chunks.
        for x in chunks:
            sys.stdout.write(x)
            try:
                if x[-1] == ")":
                    sys.stdout.write("<sbr/>\n")
                else:
                    sys.stdout.write(" ")
            except:
                pass
        sys.stdout.write("</synopsis>")
        while True:
            l = sys.stdin.readline()
            if l == "</refsect1>\n":
                sys.stdout.write("</refsynopsisdiv>\n")
                #End synopsis here.
                break
            if "<para>" in l or not "<" in l:
                sys.stdout.write(l[:-1] + "<sbr/>\n")
            else:
                sys.stdout.write(l)
    else:
        sys.stdout.write(l)
__EOF__
chmod +x passwdmanapi.xml.fix
#create passwdmanfiles.xml.fix
verbose Creating passwdmanfiles.xml.fix
echo "#!${python_exec}" > passwdmanfiles.xml.fix
cat >> passwdmanfiles.xml.fix << __EOF__
#!/usr/bin/python
import sys
while True:
    l = sys.stdin.readline()
    if len(l) < 1:
        quit()
    if "<refname>" in l:
        sys.stdout.write("<refname>~/.passwdman/passwords, ")
        sys.stdout.write("~/.passwdman/honeypots, ")
        sys.stdout.write("~/.passwdman/undoable/, ")
        sys.stdout.write("~/.passwdman/redoable/, ")
        sys.stdout.write("~/.passwdman/gui.conf</refname>\n")
    else:
        sys.stdout.write(l)
__EOF__
chmod +x passwdmanfiles.xml.fix
#create shebang script
verbose Creating shebang...
cat > shebang << __EOF__
#!/bin/sh
for test_dir in \`echo \$PATH | tr : " "\`; do
    for test_file in \`ls \$test_dir | grep ^python\`; do
        if [ -x \$test_dir/\$testfile ] ; then
            python_exec=\$test_dir/\$test_file
            break 2
        fi
    done
done
while [ \$# -gt 0 ]; do
    echo "#!\$python_exec" > \`basename \$1\`.out
    cat \$1 >> \`basename \$1\`.out
    shift
done
__EOF__
chmod +x shebang
#Create fix.docbook.
verbose Creating fix.docbook...
#printf "s/phrase Oskar Skog Aq oskar.skog.finland@gmail.com " > fix.docbook
#echo "role='author'/Oskar Skog (oskar.skog.finland@gmail.com)/" >> fix.docbook
#echo "s/();/()/" >> fix.docbook
#echo "s/(.);/()./" >> fix.docbook
#echo "s/Pa ~/~/" >> fix.docbook
cat > fix.docbook << __EOF__
s/phrase Oskar Skog Aq oskar.skog.finland@gmail.com role='author'/Oskar Skog (oskar.skog.finland@gmail.com)/
s/();/()/
s/(.);/()./
s/Pa ~/~/
__EOF__
#create cdfxm
verbose Creating cdxfm...
cat > cdxfm << __EOF__
#!/bin/sh
old_wd=\`pwd\`
cd xfilemanager-*/
\$*
cd \$old_wd
__EOF__
chmod +x cdxfm
# Crate pick-autorm
verbose Creating pick-autorm...
cat > pick-autorm << __EOF__
#!/bin/sh

if [ \$# -gt 1 ]; then
    if [ -n \$2 ]; then
        sed -f \$2 \$1 > passwdmanapi.py.out
    fi
fi

if [ \`date +%Y%m%d\` -ge 20150101 ]; then
    old_pick='s/_OLD_PICK_/False/'
else
    old_pick='s/_OLD_PICK_/True/'
fi

if [ \`date +%Y%m%d\` -ge 20150201 ]; then
    new_pick='s/_NEW_PICK_/True/'
else
    new_pick='s/_NEW_PICK_/False/'
fi

sed -e \${old_pick} \$1 | sed -e \${new_pick} > passwdmanapi.py.out
__EOF__
chmod +x pick-autorm
#create configure.2             python-script
if [ -z $python_exec ]; then
    echo "#!/usr/bin/false" > configure.2
else
    echo "#!${python_exec}" > configure.2
fi
verbose Creating configure.2...
cat >> configure.2 << __configure_EOF__
#!/usr/bin/python

copywrong = """
Copyright (c) 2013, 2014, Oskar Skog <oskar.skog.finland@gmail.com>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1.  Redistributions of source code must retain the above copyright notice,
    this list of conditions and the following disclaimer.

2.  Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE."""

__doc__ = """Second stage of configure.
This file is human generated, but generated from \`configure\`, which is
auto-generated by this file.

See also \`usage.__doc__\`.

\`\`cli = gui = guidoc = techdoc = xfm = rli = rlidoc = rli_clipboard = True\`\`

Where to install \`passwdmanapi.py\`.
-----------------------------------
ex. \`moduledir\` = \`/usr/lib/python2.7/dist-packages\`
ex. \`moduledir3\` = \`/usr/lib/python3.2/dist-packages\`

Makefile variables
------------------
\`dirs_def\`    All the long options and the defaults for variables in
              Makefile.  The first ones \`name\` **must** be
              \`\`PKGNAME\`\`!
\`dirs_set\`    Manually set directories.
\`dirs_final\`  The directory variables to use.
\`dirs_auto\`   \`dirs\` will figure out some variables.
They are lists of dictionaries of \`name\` and \`value\`.

Misc. variables
---------------
\`installed_files\`       Filled in by \`maketarget_install\` and used by
                        \`maketarget_uninstall\`.  List of strings; all
                        the installed files.
\`xfm_options\`           List of all the \`\`--with-\`\` options.  They are
                        sent to \`\`xfilemanager\`\`s \`\`configure\`\` The
                        \`\`--with-\`\` is preserved.
\`makefile\`              A file object opened by \`makemakefile\`.
\`verbose\`               bool
\`VERSION\`               str
\`LINES\`                 Used by \`update\` to make \`\`configure\`\` show
                        progress.

Other files generated by \`\`configure\`\`
--------------------------------------
\`\`shebang\`\`                     Compiler-like interface. Adds a
                                \`\`.out\`\`-suffix to it's arguments.
                                Finds the python interpreter and will
                                set the shebang line to the right path.
\`\`cdxfm\`\`                       cd into \`\`xfilemanager-*\`\` and do
                                \`\`\$*\`\`.
\`\`dirsinstall\`\`                 Force the directories \`\`\$@\`\` to exist.
\`\`passwdmanapi.xml.fix\`\`        Filter; repair broken Docbook. (Doesn't
                                validate)
\`\`passwdmanfiles.xml.fix\`\`      Filter; repair broken Docbook. (Validates)
\`\`fix.docbook\`\`                 To be fed into sed.

"""

import getopt
import sys
import os
import re

def v(x):
    """v(x) - Print message x if in verbose mode."""
    if verbose:
        print(x)

def usage():
    """Options:
  Long options; only for variables in Makefile:
    --prefix    --exec_prefix   --bindir        --datarootdir   --datadir
    --docdir    --infodir       --htmldir       --dvidir        --pdfdir
    --psdir     --localedir     --mandir
    --man1dir           --man3dir       --man5dir
    --man1ext           --man3ext       --man5ext
    --applications      /usr/share/applications         Full of '*.desktop'.
__configure_EOF__
verbose Line 100/1134...
cat >> configure.2 << __configure_EOF__
  Long and short pairs:
    --moduledir -m      Where to install the API
                                    ex. /usr/lib/python2.7/dist-packages
    --moduledir3 -m     Where to install the API
                                    ex. /usr/lib/python3.2/dist-packages
    --help      -h      All of this.
    --verbose   -v
    --disable-cli     -c    No command line interface
    --disable-gui     -g
    --disable-guidoc  -d    No documentation for the graphical user interface
    --disable-techdoc -t    No technical documentation (API and file formats)
    --disable-rli     -r    No rogue-like interface.
    --disable-rlidoc  -R
  And finally:
    --halt              No-op mode. Only generate \`configure.2\`.
    --update
    --update-from       #
    """
    print(usage.__doc__)

def unvar(thevar, thelist):
    """unvar(thevar, thelist)
    Return the value of the Makefile variable \`thevar\`.  \`thelist\` is a
    list of all the Makefile variables.  Its elements are dictionaries
    of \`name\` and \`value\`.
    
    Exmaple
    -------
    
    >>> dirs_final
    [{'name': 'bindir', 'value': '\$(prefix)/bin'}, {'name': 'prefix',
    'value': '/usr'}]
    >>> unvar('\$(bindir)', dirs_final)
    """
    chunks, out = [], ""
    for x in thelist: # Get the value and store it in var.
        if x["name"] == thevar:
            var = x["value"]
            break
    else:
        raise ValueError
    
    while True:
        x = var.split("\$", 1)   # Maybe a variable.
        chunks.append(x[0])     # The non-variable part.
        if len(x) < 2:
            break               # Next line would raise an exception.
        if x[1][0] == "(":      # Is it a variable?
            y = x[1][1:].split(")", 1)  # Break at the closing parenthesis.
            if len(y) < 2:
                chunks.append("\$(" + y) # Oops, no closing parenthesis.
                break
            var = y[1]
            chunks.append(unvar(y[0], thelist)) # Recursive (the variable).
            continue
        else:
            var = "\$" + x[1]    # No, just a normal dollar sign.
            continue
    return ''.join(chunks)

def update(x):
    """update(x)
    Regenerate configure from \`x\`, which should be \`configure.2\`.
    """
    # Load the python script x, that will be the new me.
    # Store it in configure.
    configure = open("configure", "w")
    configure.write("""#!/bin/sh
#NOTE This file is auto-generated by the python-script "configure.2", which
#is auto-generated by this file.
#Copyright (c) 2013, Oskar Skog <oskar.skog.finland@gmail.com>
#All rights reserved.
#
#Redistribution and use in source and binary forms, with or without
#modification, are permitted provided that the following conditions are met:
#
#1.  Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
#
#2.  Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
#
#THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
#AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
#IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
#ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
#LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
#CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
#SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
#INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
#CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
#ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#POSSIBILITY OF SUCH DAMAGE.
verbose_mode=0
for x in \$*; do
    if [ \$x = "--verbose" ]; then
        verbose_mode=1
        break
    fi
__configure_EOF__
verbose Line 200/1134...
cat >> configure.2 << __configure_EOF__
    if [ \$x = "-v" ]; then
        verbose_mode=1
        break
    fi
done
verbose()
{
    if [ \$verbose_mode -gt 0 ]; then
        echo \$*
    fi
}
#Important checks.
verbose Checking for python...
pyck=0          #No python.
for test_dir in \`echo \$PATH | tr : ' '\`; do
    for x in \`ls \$test_dir | grep ^python\`; do
        if [ -x \$test_dir/\$x ]; then
            pyck=1   #python
            break 2
        fi
    done
done
if [ \$pyck -eq 0 ]; then
    echo Python is required.
    exit 1
fi
#Where is python?
for test_dir in \`echo \$PATH | tr : " "\`; do
    for test_file in \`ls \$test_dir | grep ^python\`; do
        if [ -x \$test_dir/\$testfile ] ; then
            python_exec=\$test_dir/\$test_file
            break 2
        fi
    done
done
#Create dirsinstall.
verbose Creating dirsinstall...
cat > dirsinstall << __EOF__
#!/bin/sh
#This script will make sure that
#all the specified directories exist.
while [ \\\\\$# -gt 0 ]; do
    if [ -d \\\\\$1 ]; then
        shift
        continue
    fi
    mkdir \\\\\$1
    shift
done
__EOF__
chmod +x dirsinstall
#Create passwdmanapi.xml.fix.
verbose Creating passwdmanapi.xml.fix...
echo "#!\${python_exec}" > passwdmanapi.xml.fix
cat >> passwdmanapi.xml.fix << __EOF__
#!/usr/bin/python
import sys
#Fix broken Docbook XML in passwdmanapi.xml.

chunks = []

while True:
    l = sys.stdin.readline()
    if len(l) < 1:
        quit()
    if "<refsynopsisdiv" in l:
        sys.stdout.write(l)
        #Inside the bad place.
        while True:
            l = sys.stdin.readline()
            if "<command>" in l:
                sys.stdout.write("<synopsis>\\\\n#!/usr/bin/python<sbr/>\\\\n")
                continue
            if "import" in l or "passwdmanapi" in l:
                continue
            if "<sbr/>" in l:
                sys.stdout.write("import passwdmanapi<sbr/>\\\\n")
                continue
            if l == "</refsynopsisdiv>\\\\n":
                break           #Do not end synopsis here.
            try:
                chunks.append(l[37:-21])
            except:
                pass    #</synopsis>
        #Write out the chunks.
        for x in chunks:
            sys.stdout.write(x)
            try:
                if x[-1] == ")":
                    sys.stdout.write("<sbr/>\\\\n")
                else:
                    sys.stdout.write(" ")
            except:
                pass
        sys.stdout.write("</synopsis>")
        while True:
            l = sys.stdin.readline()
            if l == "</refsect1>\\\\n":
                sys.stdout.write("</refsynopsisdiv>\\\\n")
                #End synopsis here.
__configure_EOF__
verbose Line 300/1134...
cat >> configure.2 << __configure_EOF__
                break
            if "<para>" in l or not "<" in l:
                sys.stdout.write(l[:-1] + "<sbr/>\\\\n")
            else:
                sys.stdout.write(l)
    else:
        sys.stdout.write(l)
__EOF__
chmod +x passwdmanapi.xml.fix
#create passwdmanfiles.xml.fix
verbose Creating passwdmanfiles.xml.fix
echo "#!\${python_exec}" > passwdmanfiles.xml.fix
cat >> passwdmanfiles.xml.fix << __EOF__
#!/usr/bin/python
import sys
while True:
    l = sys.stdin.readline()
    if len(l) < 1:
        quit()
    if "<refname>" in l:
        sys.stdout.write("<refname>~/.passwdman/passwords, ")
        sys.stdout.write("~/.passwdman/honeypots, ")
        sys.stdout.write("~/.passwdman/undoable/, ")
        sys.stdout.write("~/.passwdman/redoable/, ")
        sys.stdout.write("~/.passwdman/gui.conf</refname>\\\\n")
    else:
        sys.stdout.write(l)
__EOF__
chmod +x passwdmanfiles.xml.fix
#create shebang script
verbose Creating shebang...
cat > shebang << __EOF__
#!/bin/sh
for test_dir in \\\\\`echo \\\\\$PATH | tr : " "\\\\\`; do
    for test_file in \\\\\`ls \\\\\$test_dir | grep ^python\\\\\`; do
        if [ -x \\\\\$test_dir/\\\\\$testfile ] ; then
            python_exec=\\\\\$test_dir/\\\\\$test_file
            break 2
        fi
    done
done
while [ \\\\\$# -gt 0 ]; do
    echo "#!\\\\\$python_exec" > \\\\\`basename \\\\\$1\\\\\`.out
    cat \\\\\$1 >> \\\\\`basename \\\\\$1\\\\\`.out
    shift
done
__EOF__
chmod +x shebang
#Create fix.docbook.
verbose Creating fix.docbook...
#printf "s/phrase Oskar Skog Aq oskar.skog.finland@gmail.com " > fix.docbook
#echo "role='author'/Oskar Skog (oskar.skog.finland@gmail.com)/" >> fix.docbook
#echo "s/();/()/" >> fix.docbook
#echo "s/(.);/()./" >> fix.docbook
#echo "s/Pa ~/~/" >> fix.docbook
cat > fix.docbook << __EOF__
s/phrase Oskar Skog Aq oskar.skog.finland@gmail.com role='author'\\
/Oskar Skog (oskar.skog.finland@gmail.com)/
s/();/()/
s/(.);/()./
s/Pa ~/~/
__EOF__
#create cdfxm
verbose Creating cdxfm...
cat > cdxfm << __EOF__
#!/bin/sh
old_wd=\\\\\`pwd\\\\\`
cd xfilemanager-*/
\\\\\$*
cd \\\\\$old_wd
__EOF__
chmod +x cdxfm
# Crate pick-autorm
verbose Creating pick-autorm...
cat > pick-autorm << __EOF__
#!/bin/sh

if [ \\\\\$# -gt 1 ]; then
    if [ -n \\\\\$2 ]; then
        sed -f \\\\\$2 \\\\\$1 > passwdmanapi.py.out
    fi
fi

if [ \\\\\`date +%Y%m%d\\\\\` -ge 20150101 ]; then
    old_pick='s/_OLD_PICK_/False/'
else
    old_pick='s/_OLD_PICK_/True/'
fi

if [ \\\\\`date +%Y%m%d\\\\\` -ge 20150201 ]; then
    new_pick='s/_NEW_PICK_/True/'
else
    new_pick='s/_NEW_PICK_/False/'
fi

sed -e \\\\\${old_pick} \\\\\$1 | sed -e \\\\\${new_pick} > passwdmanapi.py.out
__EOF__
chmod +x pick-autorm
#create configure.2             python-script
if [ -z \$python_exec ]; then
__configure_EOF__
verbose Line 400/1134...
cat >> configure.2 << __configure_EOF__
    echo "#!/usr/bin/false" > configure.2
else
    echo "#!\${python_exec}" > configure.2
fi
verbose Creating configure.2...
""")    # We're still in the function update().
    # Auto-generate configure.2.
    me = open(x, 'r')
    # The value of ender **MUST NOT** be written anywhere in this file!
    ender = "__configure" + "_EOF__"
    configure.write('cat >> configure.2 << {0}\\n'.format(ender))
    linecounter = 0
    for line in me:
        linecounter += 1
        if ender in line:
            sys.stderr.write("\`ender\` in \`line\`!\\n")
            sys.exit(1)
        # Escape some characters from being interpreted by the shell.
        configure.write(re.sub(r'([\$\`\\\\])', r'\\\\\\1', line))
        if linecounter%100 == 0:
            configure.write('''{0}
verbose Line {1}/{2}...
cat >> configure.2 << {0}
'''.format(ender, linecounter, LINES))
    configure.write("""{0}
chmod +x configure.2
verbose exec configure.2
exec ./configure.2 \$*
""".format(ender))
    configure.close()
    return

def main():
    """main() - Handle command line options."""
    global dirs_set
    global moduledir
    global verbose
    global cli
    global gui
    global guidoc
    global techdoc
    global rli
    global rlidoc
    global xfm
    global xfm_options
    long_opts = []
    for x in dirs_def[1:]:      # Skip 'PKGNAME'.
        long_opts.append(x["name"] + "=")
        # Long options for all the variables.
    long_opts.append("help")
    long_opts.append("verbose")
    long_opts.append("moduledir=")
    long_opts.append("moduledir3=")
    long_opts.append("disable-cli")
    long_opts.append("disable-gui")
    long_opts.append("disable-guidoc")
    long_opts.append("disable-techdoc")
    long_opts.append("disable-rli")
    long_opts.append("disable-rlidoc")
    long_opts.append("halt")
    long_opts.append("update")
    long_opts.append("update-from=")
    long_opts.append("version")
    long_opts.append("build=")
    long_opts.append("host=")
    long_opts.append("target=")
    long_opts.append("without-xfilemanager")
    # Handle the options.
    all_options = []
    for x in sys.argv[1:]:
        if x[:7] == "--with-":
            xfm_options.append(x)
            continue
        if x[:10] == "--without-" and x[10:] != "xfilemanager":
            sys.stdout.write("Ignoring '{0}'.\\n".format(x))
            continue
        if x[:9] == "--enable-":
            sys.stdout.write("Ignoring '{0}'.\\n".format(x))
            continue
        if x[:10] == "--disable-":
            if x[10:] != "gui":
                if x[10:] != "cli":
                    if x[10:] != "guidoc":
                        if x[10:] != "techdoc":
                            sys.stdout.write("Ignoring '{0}'.\\n".format(x))
                            continue
        all_options.append(x)
    try:
        opts, args = getopt.getopt(all_options, "hvm:M:cgdrRtu:HV", long_opts)
    except getopt.GetoptError as err:
        sys.stderr.write("{0}\\n".format(err))
        usage()
        sys.exit(1)
    del args
    for o, a in opts:
        if o in ("--help", "-h"):
            usage()
            sys.exit(0)
        elif o in ("--verbose", "-v"):
            verbose = True
__configure_EOF__
verbose Line 500/1134...
cat >> configure.2 << __configure_EOF__
            continue
        elif o in ("--moduledir", "-m"):# ex. /usr/lib/python2.7/dist-packages
            moduledir = a                 # Where passwdmanapi.py should live.
            continue
        elif o in ("--moduledir3", "-M"):
            moduledir3 = a
            continue
        elif o in ("--disable-cli", "-c"):
            cli = False
            continue
        elif o in ("--disable-gui", "-g"):
            gui = False
            guidoc = False
            continue
        elif o in ("--disable-guidoc", "-d"):
            guidoc = False
            continue
        elif o in ("--disable-techdoc", "-t"):
            techdoc = False
            continue
        elif o in ("--disable-rli", "-r"):
            rli = False
            rlidoc = False
            continue
        elif o in ("--disable-rlidoc", "-R"):
            rlidoc = False
        elif o in ("--halt", "-H"):
            quit()      # Should be renamed no-op.
        elif o in ("--update", "-u", "--update-from"):
            if len(a) > 0:      # The short option requires an argument.
                update(a)
            else:
                update(sys.argv[0])
            sys.exit(0)
        elif o in ("--version", "-V"):
            print("passwdman configure version {0}".format(VERSION))
            sys.exit(0)
        elif o == "--without-xfilemanager":
            xfm = False
            continue
        elif o in ("--build", "--host", "--target"):
            continue
        else:       # Handle options for the variable names.
            for c in dirs_def:      # Look for a match.
                if ("--" + c["name"]) == o:
                    # No duplicates.
                    i = 0       # index
                    for x in dirs_set:
                        if x["name"] == c["name"]:
                            dirs_set.pop(i)
                            break
                        else:
                            i += 1
                    if len(a) > 0:  # Empty argument resets.
                        dirs_set.append({"name": c["name"], "value": a})
                    break
            else:
                assert False, "unhandled option"

def moduledep():
    """moduledep()
    
    Check that the dependencies, for the parts of passwdman the user
    wants to be installed, exists.
    """
    global gui
    global guidoc
    global rli_clipboard
    v("Checking dependencies...")
    if gui:
        v("Module 'gi.repository.Gtk'...")
        try:
            from gi.repository import Gtk
        except:
            sys.stderr.write(
                "ERROR: Cannot import 'Gtk' from 'gi.repository'.\\n")
            sys.stderr.write(
                "ERROR: Cannot install graphical user-interface.\\n")
            print("Press control-C to stop installation.")
            gui = False
            guidoc = False
    if rli:
        v("Program 'xsel'...")
        for loopdir in os.getenv("PATH").split(":"):
            for loopfile in os.listdir(loopdir):
                if loopfile == "xsel":
                    break
            else:       #Not found here.
                continue
            break #again.
        else:
            sys.stderr.write(
                "ERROR: Cannot find 'xsel'.\\n")
            sys.stderr.write(
                "ERROR: the rogue-like interface cannot use the clipboard.\\n")
            print("Press control-C to stop installation.")
            rli_clipboard = False
    fatal = False
    v("Module 'xml.etree.ElementTree'...")
    try:
__configure_EOF__
verbose Line 600/1134...
cat >> configure.2 << __configure_EOF__
        import xml.etree.ElementTree
    except:
        sys.stderr.write("ERROR: Cannot import 'xml.etree.ElementTree',")
        sys.stderr.write(" which is required.\\n")
        fatal = True
    v("Module 'logging'...")
    try:
        import logging
    except:
        sys.stderr.write("ERROR: Cannot import 'logging',")
        sys.stderr.write(" which is required.\\n")
        fatal = True
    
    if fatal:
        sys.stderr.write("PANIC: Cannot install.\\n")
        sys.exit(1)

def dirs():
    """dirs() - Figure out the Makefile variables."""
    def tryset(x):      # Always check.
        """tryset(x) - Return True if x is not manually set."""
        for y in dirs_set:
            if y["name"] == x:
                return False
        else:
            return True
    def setvar(x, y):
        """setvar(x, y)
        
        Append name x and value y to the list of autogenerated
        variable-values. (dirs_auto)
        """
        global dirs_auto
        dirs_auto.append({"name": x, "value": y})
    def mk_dirs_final():
        """mk_dirs_final() - Make dirs_final."""
        global dirs_final
        dirs_final = []
        dirs_final.extend(dirs_set)
        dirs_final.extend(dirs_auto)
        for x in dirs_def:
            for y in dirs_final:
                if x["name"] == y["name"]:
                    break
            else:
                dirs_final.append(x)
    
    global dirs_auto
    # Check some variables.
    if tryset("prefix"):
        try:
            setvar("prefix", sys.prefix)
        except:
            pass
    if tryset("exec_prefix"):
        try:
            setvar("exec_prefix", sys.exec_prefix)
        except:
            pass
    if tryset("mandir"):
        os.system("manpath > manpath.out")
        f = open("manpath.out", "r")
        l = f.readline()[:-1]
        f.close()
        var, var2 = l.split(":"), []
        # var is now list of directories in which
        # man-pages can be installed to.
        mk_dirs_final()
        good_choice = unvar("datarootdir", dirs_final)
        for x in var:
            try:
                if x[:len(good_choice)] == good_choice and "man" in x:
                    var2.append(x)      # x is in the right datarootdir
                                        # and contains "man".
            except:
                pass
        if len(var2) == 0:
            # The user has probably specified some weird value for prefix.
            var2 = var
        
        # Pick the shortest in var2.
        while len(var2) > 1:
            # Pop the longest name.
            l = i = 0
            for x in var2:
                if len(x) > l:
                    l = len(x)
                i += 1
            var2.pop(i - 1)
        setvar("mandir", var2[0])
        
    #TODO: More.
    mk_dirs_final()

def getmoduledir():
    """getmoduledir() - Figure out where to install python modules."""
    def getmoduledir_x(pyver):
        list_of_xx = []
        path = unvar("libdir", dirs_final)
        dirlist = os.listdir(path)
__configure_EOF__
verbose Line 700/1134...
cat >> configure.2 << __configure_EOF__
        for x in dirlist:
            if pyver in x:       # pyver is either "python2" or "python3".
                try:
                    dirlist2 = os.listdir(os.path.join(path, x))
                    for y in dirlist2:
                        # \$(libdir)/*{python2,python3}*/{dist,site}-packages
                        if y in ("dist-packages", "site-packages"):
                            list_of_xx.append(os.path.join(path, x, y))
                            break
                except:
                    pass            # Names for some non-directories...
                                    # ...contain "python2" or "python3".
        else:
            if len(list_of_xx) == 1:
                # On some systems there is only one python3 directory
                # which unfortunately doesn't have a minor version.
                return list_of_xx[0]
            if len(list_of_xx) > 1:
                # Look for the newest minor.
                ver = -1
                right_version = None
                for pythonxx in list_of_xx:
                    try:
                        tmp_name = pythonxx.split("/")[-2]
                        tmp_ver = int(tmp_name.split(".")[-1])
                        if tmp_ver > ver:
                            ver = tmp_ver
                            right_version = pythonxx
                    except:
                        pass    #Garbage.
                else:
                    return right_version
            else:
                return None
    global moduledir
    global moduledir3
    if moduledir is None:
        v("Figuring out the 'moduledir' variable...")
        moduledir = getmoduledir_x("python2")
    if moduledir3 is None:
        v("Figuring out the 'moduledir3' variable...")
        moduledir3 = getmoduledir_x("python3")
    if moduledir is None and moduledir3 is None:
        sys.stderr.write("Set --moduledir manually.\\n")
        sys.exit(1)

def makemakefile():
    """makemakefile() - Open Makefile and set the variables."""
    global makefile
    v("Writing the Makefile...")
    try:
        makefile = open("Makefile", "w")
    except:
        sys.stderr.write("ERROR: cannot open 'Makefile'.\\n")
        sys.exit(1)
    makefile.write("#This file is auto-generated by configure.2.\\n")
    v("Setting the variables...")
    makefile.write("SHELL = /bin/sh\\n")
    for x in dirs_final:
        makefile.write("{0} = {1}\\n".format(x["name"], x["value"]))
    if moduledir is not None:
        makefile.write("moduledir = {0}\\n".format(moduledir))
    if moduledir3 is not None:
        makefile.write("moduledir3 = {0}\\n".format(moduledir3))

def maketarget_all():
    """maketarget_all() - Add the default 'all' target."""
    global makefile
    v("Writing the 'all.made' and 'all' targets...")
    makefile.write("all.made : shebang \$(srcdir)passwdmanapi.py")
    # Append more dependencies.
    if techdoc:
        makefile.write(" \$(srcdir)passwdmanapi.3 \$(srcdir)passwdmanfiles.5")
    if cli:
        makefile.write(" \$(srcdir)passwdmancli \$(srcdir)passwdmancli.1")
    if gui:
        makefile.write(" \$(srcdir)passwdmangui")
    if guidoc:
        makefile.write(" \$(srcdir)passwdmangui.1")
    if rli:
        makefile.write(" \$(srcdir)passwdmanrli")
    if rlidoc:
        makefile.write(" \$(srcdir)passwdmanrli.1")
    makefile.write("\\n\\t./shebang")
    if cli:
        makefile.write(" \$(srcdir)passwdmancli")
    if gui:
        makefile.write(" \$(srcdir)passwdmangui")
    if rli:
        makefile.write(" \$(srcdir)passwdmanrli")
    # pick-autorm will automatically choose which pick() OLD/NEW.
    makefile.write("\\n\\t./pick-autorm \$(srcdir)passwdmanapi.py\\n")
    # passwdmanapi.py.out
    if gui:
        makefile.write("\\tsed -e s/__XFM__/")
        if xfm:
            makefile.write("True")
        else:
            makefile.write("False")
        makefile.write("/ passwdmangui.out > passwdmangui.out.out\\n")
__configure_EOF__
verbose Line 800/1134...
cat >> configure.2 << __configure_EOF__
    if rli:
        makefile.write("\\tsed -e s/__HAVE_CLIPBOARD__/")
        if rli_clipboard:
            makefile.write("True")
        else:
            makefile.write("False")
        makefile.write("/ passwdmanrli.out > passwdmanrli.out.out\\n")
    if xfm:
        makefile.write("\\tgunzip -c \$(srcdir)xfilemanager-*.tar.gz >")
        makefile.write(" xfilemanager.tar\\n")
        makefile.write("\\ttar -xf xfilemanager.tar\\n")
        makefile.write("\\t./cdxfm ./configure ")
        if verbose:
            makefile.write("--verbose ")
        makefile.write(" ".join(xfm_options))
        for x in dirs_set:
            if x["name"] != "srcdir":
                makefile.write(" --{0}={1}".format(x["name"], x["value"]))
        makefile.write("\\n\\t./cdxfm make\\n")
    makefile.write("\\ttouch all.made\\n")    # make all, made all, all.made
    makefile.write("all : all.made\\n")          # The all target.

def maketarget_install():
    """maketarget_install() - Add the 'install' target."""
    def install_file(src, dst, x):
        """install_file(src, dst, x)
        
        Write to \`makefile\` that \`src\` must be copied to \`dst\` and that
        \`dst\` must  be chowned to root.
        
        if \`x\`: \`dst\` must be chmoded 755
        else: \`dst\` must be chmoded 644
        
        It adds \`\`\$(DESTDIR)\`\` to \`dst\`.
        It adds \`\`\$(srcdir)\`\` to \`src\` if it does not end with \`\`.out\`\`.
        It appends \`dst\` to \`installed_files\`.
        
        \`installed_files\` will be used later in \`maketarget_uninstall\`.
        """
        global installed_files
        if src[-4:] == '.out':
            srcdir = ''
        else:
             srcdir = '\$(srcdir)'
        if src[-2:] in (".1", ".3", ".5"):      #man-pages
            makefile.write("\\t-cp {2}{0} \$(DESTDIR){1}\\n".format(src, dst,
                                                                    srcdir))
        else:
            makefile.write("\\tcp {2}{0} \$(DESTDIR){1}\\n".format(src, dst,
                                                                    srcdir))
        makefile.write("\\tchown root \$(DESTDIR){0}\\n".format(dst))
        if x:
            makefile.write("\\tchmod 755 \$(DESTDIR){0}\\n".format(dst))
        else:
            if src[-2:] in (".1", ".3", ".5"):      #man-pages
                makefile.write("\\t-chmod 644 \$(DESTDIR){0}\\n".format(dst))
            else:
                makefile.write("\\tchmod 644 \$(DESTDIR){0}\\n".format(dst))
        installed_files.append(dst)
    global makefile
    v("Writing the 'install' target...")
    makefile.write("install : all.made installdirs")
    # Append more dependencies.
    if cli:
        makefile.write(" passwdmancli.out") # ./shebang adds a '.out' suffix.
    if gui:
        makefile.write(" passwdmangui.out.out \$(srcdir)passwdman.desktop")
    if rli:
        makefile.write(" passwdmanrli.out.out")
    makefile.write("\\n")
    if moduledir is not None:
        install_file("passwdmanapi.py.out", "\$(moduledir)/passwdmanapi.py",
            False)
    if moduledir3 is not None:
        install_file("passwdmanapi.py.out", "\$(moduledir3)/passwdmanapi.py",
            False)
    if techdoc:
        install_file("passwdmanapi.3", "\$(man3dir)/passwdmanapi\$(man3ext)",
                False)
        install_file("passwdmanfiles.5","\$(man5dir)/passwdmanfiles\$(man5ext)",
                False)
    if cli:
        install_file("passwdmancli.out", "\$(bindir)/passwdmancli", True)
        install_file("passwdmancli.1", "\$(man1dir)/passwdmancli\$(man1ext)",
                False)
    if gui:
        install_file("passwdmangui.out.out", "\$(bindir)/passwdmangui", True)
    if guidoc:
        install_file("passwdmangui.1", "\$(man1dir)/passwdmangui\$(man1ext)",
                False)
    if rli:
        install_file("passwdmanrli.out.out", "\$(bindir)/passwdmanrli", True)
    if rlidoc:
        install_file("passwdmanrli.1", "\$(man1dir)/passwdmanrli\$(man1ext)",
                False)
    if xfm:
        makefile.write("\\t./cdxfm make install\\n")
    makefile.write("\\t\$(POST_INSTALL)\\n")
    if gui:
        Vmaj = VERSION.split(".")[0]
__configure_EOF__
verbose Line 900/1134...
cat >> configure.2 << __configure_EOF__
        Vmin = VERSION.split(".")[1]
        makefile.write("\\tsed -e 's/_VERSION_/{0}.{1}/' ".format(Vmaj, Vmin))
        makefile.write("\$(srcdir)passwdman.desktop > ")
        makefile.write("\$(DESTDIR)\$(applications)/passwdman.desktop\\n")
        makefile.write("\\t-update-menus\\n")
    makefile.write("\\t-mandb\\n")

def maketarget_uninstall():
    """maketarget_uninstall() - Add the 'uninstall' target.
    It uses \`installed_files\` to know what to uninstall.
    """
    global makefile
    v("Writing the 'uninstall' target...")
    makefile.write("uninstall :\\n")
    for x in installed_files:
        makefile.write("\\t-rm \$(DESTDIR){0}\\n".format(x))

def maketarget__doc_(x):
    """maketarget__doc_(x) - Add the 'install-{x}' target.
    The target is not required to succeed.
    """
    global makefile
    v("Writing the 'install-{0}' and '{0}' targets...".format(x))
    makefile.write("install-{0} : {0}\\n{0} :\\n".format(x))
    if guidoc:
        makefile.write("\\t-cp \$(srcdir)passwdmangui.{0}".format(x))
        makefile.write(" \$(DESTDIR)\$({0}dir)/passwdmangui.{0}\\n".format(x))
    if cli:
        makefile.write("\\t-cp \$(srcdir)passwdmancli.{0}".format(x))
        makefile.write(" \$(DESTDIR)\$({0}dir)/passwdmancli.{0}\\n".format(x))
    if techdoc:
        makefile.write("\\t-cp \$(srcdir)passwdmanapi.{0}".format(x))
        makefile.write(" \$(DESTDIR)\$({0}dir)/passwdmanapi.{0}\\n".format(x))
        makefile.write("\\t-cp \$(srcdir)passwdmanfiles.{0}".format(x))
        makefile.write(" \$(DESTDIR)\$({0}dir)/passwdmanfiles.{0}\\n".format(x))
    if rlidoc:
        makefile.write("\\t-cp \$(srcdir)passwdmanrli.{0}".format(x))
        makefile.write(" \$(DESTDIR)\$({0}dir)/passwdmanrli.{0}\\n".format(x))

def maketarget_clean():
    """maketarget_clean() - Add 'clean' and 'maintainer-clean'."""
    v("Writing the 'clean' target...")
    makefile.write("clean :\\n\\t-rm *.made *.out configure.2\\n")
    makefile.write("\\t-rm *.1.xml *.3.xml *.5.xml\\n")
    makefile.write("\\t-rm xfilemanager.tar\\n\\t-rm -r xfilemanager-*/\\n")
    makefile.write("maintainer-clean :\\n\\t-rm *~\\n")

def maketarget_dist():
    """maketarget_dist() - Add the dist target."""
    global makefile
    v("Writing the 'dist' target...")
    # Ignore cli, gui, guidoc, and techdoc.
    makefile.write("dist : paperdoc.made")
    for x in ("api.py", "api.xml", "cli", "cli.xml", "gui", "gui.xml",
        "files.xml", "cli.html", "gui.html", "api.html", "files.html", "rli",
        "rli.xml", "rli.html", "cli.1", "api.3", "files.5", "gui.1", "rli.1"):
        makefile.write(" \$(srcdir)passwdman{0}".format(x))
    makefile.write("\\n\\t-rm -r passwdman-{0}\\n\\tmkdir passwdman-{0}\\n".format(
                                                                    VERSION))
    for x in ("api.py", "api.3", "cli", "cli.1", "gui", "gui.1", "files.5",
        "rli", "rli.1"):
        makefile.write("\\tcp \$(srcdir)passwdman{0} passwdman-{1}\\n".format(x,
                                                                VERSION))
    for f in ("html", "ps", "dvi", "pdf"):
        for n in ("api", "gui", "cli", "files", "rli"):
            makefile.write(
                "\\t-cp \$(srcdir)passwdman{0}.{1} passwdman-{2}\\n".format(n, f,
                                                                VERSION))
    for x in ("cli", "api", "gui", "files", "rli"):
        makefile.write("\\tcp \$(srcdir)passwdman{0}.xml passwdman-{1}\\n".format(
                                                                x, VERSION))
    for x in ("README", "LICENSE", "INSTALL", "NEWS", "TODO", "ChangeLog",
                "CREDITS", "configure", "FAQ"):
        makefile.write("\\tcp \$(srcdir){0} passwdman-{1}\\n".format(x, VERSION))
    makefile.write("\\tcp \$(srcdir)passwdman.desktop passwdman-{0}\\n".format(
                                                                    VERSION))
    makefile.write("\\t-cp xfilemanager-*.tar.gz passwdman-{0}\\n".format(
                                                                    VERSION))
    makefile.write("\\ttar -cf passwdman-{0}.tar passwdman-{0}"
                        " \\n\\tgzip passwdman-{0}.tar\\n".format(VERSION))

def maketarget_installdirs():
    """maketarget_installdirs() - Add the 'installdirs' target."""
    global makefile
    makefile.write("installdirs : dirsinstall\\n\\t./dirsinstall")
    for x in dirs_final:
        if "man" in x["name"] and "ext" in x["name"]:
            # '.1', '.3', '.5'
            continue
        if x["name"] in ("srcdir", "DESTDIR", "PKGNAME"):
            continue
        makefile.write(" \$(DESTDIR)\$({0})".format(x["name"]))
    makefile.write("\\n")

def maketarget__doc_auto():
    """maketarget__doc_auto()
    It is for me. I make things in the current directory.
    mdoc -> [doclifter] -> Docbook -> [sed + scripts + xmlto] ->
        ([sed] -> xhtml, pdf, ps)
    """
__configure_EOF__
verbose Line 1000/1134...
cat >> configure.2 << __configure_EOF__
    global makefile
    f = open("xml.copyright", "w")
    f.write("""
<!-- Copyright (c) 2013, 2014, Oskar Skog <oskar.skog.finland@gmail.com>
All rights reserved. -->

<!-- Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:-->

<!-- 1.  Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer. -->

<!-- 2.  Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution. -->

<!-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE. -->
""")
    f.close()
    for n, s in (("passwdmangui", 1), ("passwdmanfiles", 5),
                 ("passwdmancli", 1), ("passwdmanapi", 3),
                 ("passwdmanrli", 1)):
        # Docbook
        makefile.write("{0}.xml : {0}.{1}\\n".format(n , str(s)))
        makefile.write("\\tdoclifter {0}.{1}\\n".format(n, str(s)))
        # NOTE to self: doclifter-2.13
        # They all need some help.
        makefile.write("\\tsed -f fix.docbook {0}.{1}.xml > {0}.xml\\n".format(
                                                                n, str(s)))
        if n == "passwdmanapi":                 # It needs lots of help,
                                            # it still doesn't validate.
            makefile.write("\\tcat passwdmanapi.xml | ./passwdmanapi.xml.fix ")
            makefile.write("> passwdmanapi.xml.out\\n")
            makefile.write("\\tmv passwdmanapi.xml.out passwdmanapi.xml\\n")
        if n == "passwdmanfiles":
            makefile.write("\\tcat passwdmanfiles.xml | ")
            makefile.write("./passwdmanfiles.xml.fix >")
            makefile.write("passwdmanfiles.xml.out\\n")
            makefile.write("\\tmv passwdmanfiles.xml.out passwdmanfiles.xml\\n")
        # html, pdf, ps
        for fn, fc in (("html", "xhtml-nochunks"), ("ps", "--with-fop ps"),
                       ("pdf", "--with-fop pdf")):
            makefile.write("{0}.{1} : {0}.xml\\n\\txmlto ".format(n, fn))
            if n == "passwdmanapi":
                makefile.write("--skip-validation ")
            makefile.write("{0} {1}.xml\\n".format(fc, n))
            if fn == "html":
                makefile.write("\\tsed -e 's/type=\\"bullet\\"/type=\\"disc\\"/'")
                makefile.write(" {0}.html > {0}.htmlout\\n".format(n))
                makefile.write("\\tmv {0}.htmlout {0}.html\\n".format(n))

def maketarget_paperdoc():
    """maketarget_paperdoc() - Add the target paperdoc.made, which just
    depends on lots of files."""
    makefile.write("paperdoc.made :")
    for x in ("passwdmanfiles", "passwdmancli", "passwdmanapi",
                "passwdmangui", "passwdmanrli"):
        for y in ("ps", "pdf"):
            makefile.write(" {0}.{1}".format(x, y))
    makefile.write("\\n\\ttouch paperdoc.made\\n")

# All the long options and the defaults for variables in Makefile.

dirs_def= [ {"name": "PKGNAME", "value": "passwdman"},
        {"name": "prefix", "value": "/usr/local"},
        {"name": "exec_prefix", "value": "\$(prefix)"},
        {"name": "bindir", "value": "\$(exec_prefix)/bin"},
        {"name": "datarootdir", "value": "\$(prefix)/share"},
        {"name": "datadir", "value": "\$(datarootdir)"},
        {"name": "docdir", "value": "\$(datarootdir)/doc/\$(PKGNAME)"},
        {"name": "infodir", "value": "\$(datarootdir)/info"},
        {"name": "htmldir", "value": "\$(docdir)"},
        {"name": "dvidir", "value": "\$(docdir)"},
        {"name": "pdfdir", "value": "\$(docdir)"},
        {"name": "psdir", "value": "\$(docdir)"},
        {"name": "localedir", "value": "\$(datarootdir)/locale"},
        {"name": "mandir", "value": "\$(datarootdir)/man"},
        {"name": "man1dir", "value": "\$(mandir)/man1"},
        {"name": "man3dir", "value": "\$(mandir)/man3"},
        {"name": "man5dir", "value": "\$(mandir)/man5"},
        {"name": "man1ext", "value": ".1"},
        {"name": "man3ext", "value": ".3"},
        {"name": "man5ext", "value": ".5"},
        {"name": "libdir", "value": "\$(exec_prefix)/lib"},
        {"name": "applications", "value": "\$(datarootdir)/applications"},
        {"name": "srcdir", "value": ""},
        {"name": "DESTDIR", "value": ""}]
# These booleans will be used when generating Makefile.
cli = gui = guidoc = techdoc = xfm = rli = rlidoc = rli_clipboard = True
verbose = False
__configure_EOF__
verbose Line 1100/1134...
cat >> configure.2 << __configure_EOF__
# Where to install passwdmanapi.py.
# ex. moduledir = '/usr/lib/python2.7/dist-packages'
# ex. moduledir3 = '/usr/lib/python3.2/dist-packages'
moduledir = None
moduledir3 = None
dirs_set = []           # Manually set directories.
dirs_final = []         # The directory variables to use.
dirs_auto = []          # dirs() will figure them out.
installed_files = []    # Filled in by maketarget_install and used by
                        # maketarget_uninstall.
xfm_options = []
makefile = None
VERSION = "0.4.8"
LINES = 1134
if __name__ == "__main__":
    main()              # Handle options.
    moduledep()         # Check dependencies
    dirs()              # Figure out some directories.
    getmoduledir()      # Figure out where to put passwdmanapi.py.
    makemakefile()      # Open Makefile and set the variables.
    maketarget_all()
    maketarget_install()
    maketarget_uninstall()
    maketarget__doc_("html")
    maketarget__doc_("pdf")
    maketarget__doc_("ps")
    maketarget__doc_("dvi")
    maketarget_clean()
    maketarget_dist()
    maketarget_installdirs()
    maketarget__doc_auto()
    maketarget_paperdoc()       # PDF/PS paperdoc.made
    makefile.close()
__configure_EOF__
chmod +x configure.2
verbose exec configure.2
exec ./configure.2 $*
